from flask import current_app
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
from werkzeug import generate_password_hash, check_password_hash
from flask.ext.login import UserMixin
from app import db, login_manager
from app.email import send_email


class Role(db.Model):
    """Table representing user roles.

    Database Columns:
        id -- Auto-generated ID number.
        name -- What we call the role.
    Relationships:
        users -- backrefs 'role' to User.
    """
    __tablename__ = 'roles'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    users = db.relationship('User', backref='role', lazy='dynamic')

    def __repr__(self):
        return '<{0} \'{1}\'>'.format(self.__class__.__name__, self.name)


class User(UserMixin, db.Model):
    """Table representing registered users.

    Database Columns:
        id -- Identification number automatically generated by database.
        confirmed -- Whether or not user's account is confirmed.
        email -- The user's email address.
        name -- The name/nickname the user uses on the site.
        password_hash -- Hashed user password.
        role_id -- ID number of a Role.
    Relationships:
        role -- backref from Role.
    Methods:
        generate_confirmation_token -- Creates a secure token for account
                                       confirmation.
        confirm -- Takes a token and sets confirmed to True if the token
                   is a valid confirmation token for this user.
        password -- Saves a hashed password to password_hash.
        verify_password -- Returns True if password is correct.
    """
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    confirmed = db.Column(db.Boolean, default=False)
    email = db.Column(db.String(254), unique=True)
    name = db.Column(db.String(64), unique=True)
    password_hash = db.Column(db.String(128))
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))

    def confirm_token(self, token):
        s = Serializer(current_app.config['SECRET_KEY'])
        try:
            data = s.loads(token)
        except:
            return False
        if data.get('confirm') != self.id:
            return False
        return True

    def generate_confirmation_token(self, expiration=3600):
        s = Serializer(current_app.config['SECRET_KEY'], expiration)
        return s.dumps({'confirm': self.id})

    @property
    def password(self):
        raise AttributeError('password is not a readable attribute!')

    @password.setter
    def password(self, password):
        """This is a convenience function so you can use User.password = x"""
        # IMO, this method of setting password_hash is too opaque.
        # User.set_password makes it more obvious that the password is being
        # acted on by a function, so I recommend that instead. -N
        self.set_password(password)

    def send_confirmation_email(self):
        token = self.generate_confirmation_token()
        send_email(self.email, 'Confirm Your Account',
                   'auth/email/confirmation', user=self, token=token)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password):
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return '<{0} \'{1}\'>'.format(self.__class__.__name__, self.name)


def get_user_from_confirmation_token(token):
    s = Serializer(current_app.config['SECRET_KEY'])
    try:
        data = s.loads(token)
    except:
        raise ValueError('Token is malformed or invalid!')
    if 'confirm' in data:
        user = User.query.filter_by(id=data['confirm']).first()
        if user.confirmed is True:
            raise ValueError('The user for this token is already confirmed!')
        else:
            return user
    else:
        raise KeyError('Confirmation token toes not contain valid data!')


@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))
