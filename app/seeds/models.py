# -*- coding: utf-8 -*-
# This file is part of SGS-Flask.

# SGS-Flask is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# SGS-Flask is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Copyright Swallowtail Garden Seeds, Inc


"""
app.seeds.models

This module contains SQLAlchemy declarative models for product (seeds)
information, along with functions that assist in working with the data in
the models. Each model class represents a table in the database used by this
application.

There are some shorthand terms that are used in docs in this module, and in
naming instances of models throughout the rest of sgs_flask.

Notes:
    Shorthand:

    In the docs, these shorthand terms are used to describe relationships:
        OtM - One to Many
        MtO - Many to One
        MtM - Many to Many
        OtO - One to One

    When creating instances of various models, it is often easier to use
    shorthand versions of their names, which are typically created by removing
    as many characters from the name as possible while still keeping it
    distinct and (hopefully) fairly obvious. The most common ones:
        idx - Index
        cn - CommonName
        bn - BotanicalName
        sr - Series
        cv - Cultivar
        pkt - Packet
        qty - Quantity

    Common Attributes Not Documented in Class Docstrings:

    All models contain the attributes __tablename__ and id, but they're not
    documented in each model, as they're fairly straightforward and obvious if
    one is familiar with SQLAlchemy. Just in case, though, here's what they
    are:
        __tablename__: The name of the table. This usually corresponds to the
            name of the model itself, eg the tablename for Index is 'indexes'.
        id: An integer used as the primary key for a model. It is automatically
            generated by SQLAlchemy when a new model instance is flushed to the
            database. While it's (usually) okay to set this value manually in
            tests, it should *never* be set manually in production code, as
            each id must be unique!

    Any attribute ending in _id is a foreign key used to create a relationship
    between two tables. In MtO and OtM relationships it will be defined right
    before the relationship it's for, and it will be named <relationship>_id.
    In MtM relationships, it will be specified in the appropriate association
    table.

"""

import json
import os
from decimal import Decimal, ROUND_DOWN

from flask import current_app
from fractions import Fraction
from inflection import pluralize
from slugify import slugify
from titlecase import titlecase
from sqlalchemy import event, inspect
from sqlalchemy.ext.hybrid import Comparator, hybrid_property
from sqlalchemy.orm.mapper import Mapper
from sqlalchemy.sql.expression import and_
from flask_sqlalchemy import SignallingSession

from app import db


# Session Info Handling
@event.listens_for(Mapper, 'after_configured', once=True)
def intitialize_session_info():
    """Set up `db.session.info`

    This way we ensure that keys in `db.session.info` will (hopefully) exist
    before any attempt is made to access them.

    This is done here because `db.session` has not been initialized until after
    this file has been parsed, so attempting to use `db.session` in the global
    namespace of this module will result in a `RuntimeError`.
    """
    db.session.info['pending_commit'] = False


@event.listens_for(SignallingSession, 'after_flush')
def set_pending_commit_after_flush(session, flush_context):
    """Set pending_commit to True if session flushed with changes.

    This way we know changes have been made, but still need to be committed.
    This takes a lot of the hassle out of figuring out whether or not changes
    have been made during editing, as any changes can be flushed once made, and
    we know from pending_commit whether or not changes have been made.
    """
    if session.new or session.dirty or session.deleted:
        session.info['pending_commit'] = True


@event.listens_for(SignallingSession, 'after_commit')
def set_pending_commit_after_commit(session):
    """Set pending_commit to False after commit.

    Obviously, the session isn't pending commit once it's been committed.
    """
    session.info['pending_commit'] = False


@event.listens_for(SignallingSession, 'after_rollback')
def set_pending_commit_after_rollback(session):
    """Set pending_commit to False after rollback.

    If the session has been rolled back, there are no changes to commit.
    """
    session.info['pending_commit'] = False


# Association Tables
botanical_names_to_common_names = db.Table(
    'botanical_names_to_common_names',
    db.Model.metadata,
    db.Column('botanical_names_id',
              db.Integer,
              db.ForeignKey('botanical_names.id')),
    db.Column('common_names_id', db.Integer, db.ForeignKey('common_names.id'))
)


cultivars_to_custom_pages = db.Table(
    'cultivars_to_custom_pages',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('custom_pages_id', db.Integer, db.ForeignKey('custom_pages.id'))
)


cultivars_to_images = db.Table(
    'cultivars_to_images',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


# Module-level Functions
def dbify(string):
    """Format a string to be stored in the database.

    Args:
        string (str): The string to be converted.

    Returns:
        str: A string formatted for database usage.
        None: If string is None or empty.
    """
    def cb(word, **kwargs):
        """Override default behaviors in titlecase that give incorrect results.

        Hyphenated phrases should only capitalize the first letter. The default
        behavior of titlecase is to capitalize the first letter in each part.
        e.g forget-me-not > Forget-Me-Not, while we want forget-me-not >
        Forget-me-not.

        Returns:
            str: Corrected hyphenated word.
        """
        if '-' in word:
            return word[0].upper() + word[1:].lower()

    if string:
        return titlecase(string.lower().strip(), callback=cb)
    else:
        return None


# Helper Classes
class SynonymsMixin(object):
    """A mixin class to easily interact with synonyms in child classes."""
    @property
    def synonyms_string(self):
        """str: A list of Synonyms for the parent object.

        The setter parses a string list of synonyms and adds loaded or created
        synonyms to the object's synonyms. If a falsey value is set, it removes
        all synonyms from the object and deletes any synonyms which no longer
        belong to any object.
        """
        if self.synonyms:
            return ', '.join([syn.name for syn in self.synonyms])
        else:
            return ''

    @synonyms_string.setter
    def synonyms_string(self, synonyms):
        db_changed = False
        syns = synonyms.split(', ') if synonyms else []
        for syn in list(self.synonyms):
            if syn.name not in syns:
                self.synonyms.remove(syn)
                if inspect(syn).persistent:
                    db_changed = True
                    db.session.delete(syn)
        for syn in syns:
            if syn.isspace():
                syn = None
            if syn and syn not in [syno.name for syno in self.synonyms]:
                db_changed = True
                self.synonyms.append(Synonym(name=syn))
        if db_changed:
            db.session.flush()


# TypeDecorators
class USDollar(db.TypeDecorator):
    """Type for US dollar amounts to be stored in the database.

    Since we don't know for sure how the database will handle decimal numbers,
    it is safer to store our dollar amounts as integers to avoid the risk of
    floating point errors leading to incorrect data. Therfore, values will be
    stored in cents and converted back to dollars upon retrieval.

    A USDollar column will store a value of 2.99 as 299 in the database, and
    return it as 2.99 when retrieved.

    Attributes:
        impl: The type of column this decorates: `sqlalchemy.types.Integer`.
    """
    impl = db.Integer

    def process_bind_param(self, value, dialect):
        if value is None:  # pragma: no cover
            return None
        else:
            return USDollar.usd_to_cents(value)

    def process_result_value(self, value, dialect):
        if value is None:  # pragma: no cover
            return None
        else:
            return USDollar.cents_to_usd(value)

    @staticmethod
    def cents_to_usd(cents):
        """Convert a value in cents into a value in dollars.

        Args:
            cents: An integer value in cents to be converted to a decimal
                dollar value.

        Returns:
            Decimal: US cents converted to US dollars and quantized to
                always have two digits to the right of the decimal.

        Examples:
            >>> USDollar.cents_to_usd(100)
            Decimal('1.00')

            >>> USDollar.cents_to_usd(350)
            Decimal('3.50')

            >>> USDollar.cents_to_usd(2999)
            Decimal('29.99')

        """
        cents = int(cents)
        return (Decimal(cents) / 100).\
            quantize(Decimal('1.00'))

    @staticmethod
    def usd_to_decimal(usd):
        """Convert a US dollar value to a `Decimal`.

        Args:
            usd: The value to convert to `Decimal`.

        Examples:

            >>> USDollar.usd_to_decimal(3.5)
            Decimal('3.50')

            >>> USDollar.usd_to_decimal(2)
            Decimal('2.00')

            >>> USDollar.usd_to_decimal('9.99')
            Decimal('9.99')

            >>> USDollar.usd_to_decimal('$5')
            Decimal('5.00')

            >>> USDollar.usd_to_decimal('$ 4.49')
            Decimal('4.49')

            >>> USDollar.usd_to_decimal('3$')
            Decimal('3.00')
        """
        usd = str(usd).replace('$', '').strip()
        return Decimal(usd).quantize(Decimal('1.00'), rounding=ROUND_DOWN)

    @staticmethod
    def usd_to_cents(usd):
        """Convert a US dollar amount to cents.

        Args:
            usd: A US Dollar amount to convert to cents.

        Examples:

            >>> USDollar.usd_to_cents(Decimal('1.99'))
            199

            >>> USDollar.usd_to_cents(5)
            500

            >>> USDollar.usd_to_cents('$2.99')
            299

            >>> USDollar.usd_to_cents('2.5')
            250
        """
        return (int(USDollar.usd_to_decimal(usd) * 100))


# Models
class Index(db.Model):
    """Table for seed indexes.

    Indexes are the first/broadest divisions we use to sort seeds. The
    `Index` a seed falls under is usually based on what type of plant it is
    (herb, vegetable) or its life cycle. (perennial, annual)

    Attributes:
        name: The name for the `Index` itself, such as 'Herb'  or 'Perennial'.
        slug: A URL-safe version of _name.
        description: An optional HTML description of the `Index`.

        common_names: Backref from `CommonName.index`.
    """
    __tablename__ = 'indexes'
    id = db.Column(db.Integer, primary_key=True)

    # Data Required
    name = db.Column(db.String(64), unique=True)
    slug = db.Column(db.String(64), unique=True)

    # Data Optional
    description = db.Column(db.Text)

    def __init__(self, name=None, description=None):
        """Construct an instance of Index.

        Args:
            name: The name of the Index.
            description: An optional HTML description of this Index.
        """
        self.name = name
        self.description = description

    def __repr__(self):
        return '<{0} \'{1}\'>'.format(self.__class__.__name__,
                                      self.name)

    @property
    def header(self):
        """str: contents of `name` in a str for headers, titles, etc."""
        # TODO : Maybe make the string setable via config?
        return '{0} Seeds'.format(self.name)

    @property
    def plural(self):
        """str: plural form of `name`."""
        return pluralize(self.name) if self.name is not None else None

    def generate_slug(self):
        """Generate the string to use in URLs containing this `Index`."""
        return slugify(self.plural) if self.name is not None else None

    @classmethod
    def save_to_json_file(cls, json_file=None):
        """Save given or all `Index` instances to a JSON file.

        Args:
            json_file: Optional filename to save JSON indexes to. If not given,
                it will default to `config.INDEXES_JSON_FILE`.

        Since indexes are rarely changed and there are only going to be a
        handful of them, it is better to store them in a JSON file and load
        them that way in the main nav interface, as otherwise there would a db
        query for `Index` values every time a page with the main nav is loaded.
        """
        indexes = cls.query.all()
        if not json_file:
            json_file = current_app.config.get('INDEXES_JSON_FILE')
        with open(json_file,
                  'w',
                  encoding='utf-8') as ofile:
            ofile.write(
                json.dumps({idx.id: (idx.header, idx.slug) for idx in indexes})
            )


@event.listens_for(Index, 'before_insert')
@event.listens_for(Index, 'before_update')
def before_index_insert_or_update(mapper, connection, target):
    """Run tasks best done before flushing an `Index` to the database."""
    target.name = dbify(target.name)
    target.slug = target.generate_slug()


@event.listens_for(SignallingSession, 'before_commit')
def save_indexes_json_before_commit(session):
    """Save Indexes if any have been added, edited, or deleted."""
    if any(isinstance(obj, Index) for obj in db.session):
        # It is appropriate to run `save_indexes_to_json_file` even if there
        # are deleted `Index` instances in the session, because the deleted
        # instances will not be returned by `Index.query.all()`, so deleted
        # indexes will be removed from the indexes JSON file.
        Index.save_to_json_file()


class CommonName(SynonymsMixin, db.Model):
    """Table for common names.

    A `CommonName` is the next subdivision below `Index` in how we sort seeds.
    It is usually the common name for the species or group of species a seed
    belongs to.

    Attributes:
        index: MtO relationship with `Index`; the `Index` this `CommonName`
            falls under.
            Backref: `Index.common_names`
        name: The common name of a seed. Examples: Coleus, Tomato,
            Lettuce, Zinnia.
        slug: The URL-friendly version of this common name.

        description: An optional HTML description for this CommonName.
        instructions: Optional planting instructions for seeds with the
            specified CommonName.
        parent: An optional `CommonName` this is a subcategory of. For example,
            if this `CommonName` is 'Dwarf Coleus', it would have 'Coleus' as
            its parent.
            Backref: `CommonName.children`
        invisible: True if the specified `CommonName` is to be shown on auto-
            generated pages, False if it should only be shown on custom pages
            that explicitly include it. Default value: False.

        children: Backref from `CommonName.parent`.
        botanical_names: Backref from `BotanicalName.common_names`.
        series: Backref from `Series.common_name`. Note: series is plural here,
            as this is the many side of the relationship.
        cultivars: Backref from `Cultivar.common_name`.
        synonyms: Backref from `Synonym.common_name`.
    """
    __tablename__ = 'common_names'
    __table_args__ = (db.UniqueConstraint('name',
                                          'index_id',
                                          name='cn_index_uc'),)
    id = db.Column(db.Integer, primary_key=True)

    # Data Required
    index_id = db.Column(db.Integer, db.ForeignKey('indexes.id'))
    index = db.relationship('Index', backref='common_names')
    name = db.Column(db.String(64))
    slug = db.Column(db.String(64))

    # Data Optional
    description = db.Column(db.Text)
    instructions = db.Column(db.Text)
    parent_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    parent = db.relationship('CommonName',
                             backref='children',
                             foreign_keys=parent_id,
                             remote_side=[id])
    invisible = db.Column(db.Boolean, default=False)

    def __init__(self,
                 name=None,
                 index=None,
                 description=None,
                 instructions=None,
                 parent=None,
                 invisible=None):
        """Construct an instance of `CommonName`."""
        self.name = name
        self.index = index
        self.description = description
        self.instructions = instructions
        self.parent = parent
        if invisible is not None:  # Do not override default value
            self.invisible = invisible

    def __repr__(self):
        return '<{0} \'{1}\'>'.format(self.__class__.__name__, self.name)

    @property
    def header(self):
        """str: `name` formatted for headers and titles."""
        return '{0} Seeds'.format(self.name)

    @property
    def select_field_title(self):
        """str: The title to use for a given `CommonName` in select fields."""
        if self.index and self.index.name:
            return '{0} ({1})'.format(self.name, self.index.name)
        else:
            return self.name

    @property
    def queryable_dict(self):
        """dict: The values needed to query a discrete `Cultivar` instance."""
        return {
            'Common Name': self.name,
            'Index': self.index.name if self.index else None
        }

    @classmethod
    def from_queryable_values(cls, name, index):
        """Return a `CommonName` instance filtered by `name` and `index`.

        Args:
            name: The name of the `CommonName` instance to query for.
            index: The name of the `Index` the `CommonName` instance being
                queried for belongs to.

        Returns:
            CommonName: A discrete instance of `CommonName`.
        """
        return cls.query\
            .join(Index, Index.id == cls.index_id)\
            .filter(cls.name == name, Index.name == index)\
            .one_or_none()

    @classmethod
    def from_queryable_dict(cls, d):
        """Return a `CommonName` instance with information from a dict.

        Args:
            d: A dict containing the name and index name of a `CommonName`.

        Returns:
            CommonName: A discrete instance of `CommonName`.
        """
        return cls.from_queryable_values(name=d['Common Name'],
                                         index=d['Index'])

    def generate_slug(self):
        """Generate the string to use in URLs for this `CommonName`."""
        return slugify(self.name) if self.name is not None else None


@event.listens_for(CommonName, 'before_insert')
@event.listens_for(CommonName, 'before_update')
def before_common_name_insert_or_update(mapper, connection, target):
    """Run tasks best done before flushing a `CommonName` to the database."""
    target.name = dbify(target.name)
    target.slug = target.generate_slug()


class BotanicalName(SynonymsMixin, db.Model):
    """Table for botanical (scientific) names of seeds.

    The botanical name is the scientific name of the species a seed belongs
    to. A correctly-formatted botanical name begins with a genus and species
    in binomial name format, or at least a genus followed by a descriptive
    comment.

    Attributes:
        name: A botanical name associated with one or more seeds. Get
            and set via the name property.
        common_names: MtM relationship with `CommonName`; The CommonNames this
            botanical name belongs to. A botanical name can have multiple
            common names because sometimes there are multiple common names for
            a species of plant, or there could be a species that falls under
            multiple indexes, which results in multiple common names with the
            same name but different indexes.
            Backref: `CommonName.botanical_names`

        synonyms: Backref from `Synonyms.botanical_name`.
        cultivars: Backref from `Cultivar.botanical_name`.
    """
    __tablename__ = 'botanical_names'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    common_names = db.relationship(
        'CommonName',
        secondary=botanical_names_to_common_names,
        backref='botanical_names'
    )

    def __init__(self, name=None, common_names=None, synonyms=None):
        """Construct an instance of BotanicalName.

        Note:
            synonyms should be a string, not a collection of `Synonym` objects,
            as the only relevant data `Synonym` objects contain is the synonyms
            themselves.
        """
        self.name = name
        if common_names:  # Can't set collection to None
            self.common_names = common_names
        self.synonyms_string = synonyms

    def __repr__(self):
        """Return representation of BotanicalName in human-readable format.

        Returns:
            str: Representation formatted <BotanicalName '<.name>'> for
                 example: <BotanicalName 'Asclepias incarnata'>
        """
        return '<{0} \'{1}\'>'.format(self.__class__.__name__,
                                      self.name)

    @staticmethod
    def validate(botanical_name):
        """Return True if botanical_name looks like a valid botanical name.

        Since there is a lot of variation in what constitutes a valid botanical
        name, the best we can reasonably do is make sure it contains at least
        two words, and the first could be a validly formatted genus.

        Examples:
            >>> BotanicalName.validate('Asclepias incarnata')
            True

            >>> BotanicalName.validate('asclepias incarnata')
            False

            >>> BotanicalName.validate('ASCLEPIAS INCARNATA')
            False

            >>> BotanicalName.validate('Asclepias Incarnata')
            True

            >>> BotanicalName.validate('Digitalis interspecies hybrid')
            True

        Args:
            botanical_name: A string containing a botanical name to
                check for valid formatting.

        Returns:
            bool: True if botanical_name looks valid, False if it doesn't look
                valid, or if attempting to parse it raises an exception.
        """
        try:
            nomens = botanical_name.strip().split(' ')
            if len(nomens) > 1 and nomens[0] == nomens[0].capitalize():
                return True
            else:
                return False
        except:
            return False


@event.listens_for(BotanicalName, 'before_insert')
@event.listens_for(BotanicalName, 'before_update')
def before_botanical_name_insert_or_update(mapper, connection, target):
    """Run tasks best run before adding a `BotanicalName` to the database."""
    # Validating `BotanicalName.name` should always be handled at the highest
    # level possible. Generally, this is either when a user inputs a name, or
    # a name is loaded from a file. This check exists so that failures to
    # validate `BotanicalName.name` before attempting to add it to the database
    # are caught.
    #
    # This exception should **never** be raised in production code!
    if not BotanicalName.validate(target.name):
        raise ValueError('An attempt to insert an invalid BotanicalName into '
                         'the database has occurred! Please ensure the name '
                         'of any new or edited BotanicalName is validated '
                         'before attempting to flush it to the database. You '
                         'can use BotanicalName.validate(name) to check '
                         'whether or not a name is valid.')


class Series(db.Model):
    """Table for seed series.

    A series is an optional subclass of a given cultivar type, usually created
    by the company that created the cultivars within the series. Examples
    include Benary's Giant (zinnias), Superfine Rainbow (coleus), and Heat
    Elite Mambo (petunias).

    Attributes:
        BEFORE_CULTIVAR: A constant integer representing that series name
            should come before the cultivar name when displayed together.
        AFTER_CULTIVAR: A constant integer representing that series name should
            come after the cultivar when displayed together.

        name: The name of the series.
        common_name: MtO relationship with `CommonName`; the common name a
            Series belongs to.
            Backref: `CommonName.series`

        description: An HTML description of the series.
        position: An integer representing whether the series name belongs
            before or after the cultivar name when displayed together. Default
            value is `BEFORE_CULTIVAR`.

        cultivars: Backref from `Cultivar.series`.
    """
    __tablename__ = 'series'
    __table_args__ = (db.UniqueConstraint('name',
                                          'common_name_id',
                                          name='_series_name_cn_uc'),)
    id = db.Column(db.Integer, primary_key=True)

    # Constants
    BEFORE_CULTIVAR = 0
    AFTER_CULTIVAR = 1

    # Data Required
    name = db.Column(db.String(64))
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship('CommonName', backref='series')

    # Data Optional
    description = db.Column(db.Text)
    position = db.Column(db.Integer, default=BEFORE_CULTIVAR)

    def __init__(self,
                 name=None,
                 common_name=None,
                 description=None,
                 position=None):
        """Create an instance of a Series."""
        self.name = name
        self.common_name = common_name
        self.description = description
        if position is not None:
            self.position = position

    def __repr__(self):
        """Return a string representing a `Series` instance."""
        return '<{0} \'{1}\'>'.format(self.__class__.__name__, self.fullname)

    @property
    def fullname(self):
        """str: Name of `Series` with name of `CommonName`."""
        fn = []
        if self.name:
            fn.append(self.name)
        if self.common_name:
            fn.append(self.common_name.name)
        if fn:
            return ' '.join(fn)
        else:
            return None


@event.listens_for(Series, 'before_insert')
@event.listens_for(Series, 'before_update')
def before_series_insert_or_update(mapper, connection, target):
    """Run tasks on `Series` that should be done before flush."""
    target.name = dbify(target.name)
    if target.cultivars:
        for cv in target.cultivars:
            cv.slug = cv.generate_slug()


class Cultivar(SynonymsMixin, db.Model):
    """Table for cultivar data.

    A cultivar is an individual variety of plant, and represents the most
    specific category seeds fall under. This is the primary attribute that
    products (packets) are attached to.

    Note:
        A cultivar must have a unique combination of name, common name, and
        series, otherwise it could result in multiple results from a query
        intended to fetch only one cultivar. Series can be None, as long as
        the cultivar is still a unique combination. For example, Polkadot
        Petra Foxglove and Petra Foxglove (if it existed) would qualify as
        unique due to one having a series and the other not, even though they
        have the same _name and common name.

    Attributes:
        name: The part of the cultivar's name that is specific to the cultivar
            itself, e.g. if a cultivar is called "Foxy Foxglove", name will be
            "Foxy".
        slug: A URL-friendly version of _name.
        common_name: MtO relationship with `CommonName`; the common name a
            cultivar falls under.
            Backref: `CommonName.cultivars`

        series: MtO relationship with `Series`; the (optional) series a
            cultivar belongs to. While it is optional, it must be used in
            queries for cultivars to ensure a unique result. Queries for
            cultivars that are not in a series should include
            Cultivar.series == None in the filter.
            Note: '==' is used instead of 'is' due to sqlalchemy treating
            'x == None' as 'x is None' in filters.
            Backref: `Series.cultivars`
        botanical_name: MtO relationship with `BotanicalName`; the botanical
            name of this cultivar.
            Backref: `BotanicalName.cultivars`
        description: An optional HTML description of a cultivar.
        new_until: An optional date to mark a `Cultivar` as new until.
        active: True if the cultivar's stock is being actively replenished,
            False if not.
        in_stock: True if a cultivar is in stock, False if not.
        invisible: Whether or not this cultivar should be shown on
            automatically generated pages. Cultivars set to invisible can still
            be shown on custom pages.
        thumbnail: OtO relationship with `Image`; thumbnail data for this
            cultivar.
            Backref: `Image.cultivar`
        images: MtM relationship with `Image`; images which include this
            cultivar.
            Backref: `Image.cultivars`

        synonyms: Backref from `Synonym.cultivar`.
        packets: Backref from `Packet.cultivar`.
        custom_pages: Backref from `CustomPage.cultivar`.
    """
    __tablename__ = 'cultivars'
    id = db.Column(db.Integer, primary_key=True)
    __table_args__ = (db.UniqueConstraint('name',
                                          'common_name_id',
                                          'series_id',
                                          name='_cultivar_name_cn_series_uc'),)

    # Data Required
    name = db.Column(db.String(64))
    slug = db.Column(db.String(64))
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship('CommonName', backref='cultivars')

    # Data Optional
    series_id = db.Column(db.Integer, db.ForeignKey('series.id'))
    series = db.relationship('Series', backref='cultivars')
    botanical_name_id = db.Column(db.Integer,
                                  db.ForeignKey('botanical_names.id'))
    botanical_name = db.relationship('BotanicalName',
                                     backref='cultivars')
    description = db.Column(db.Text)
    new_until = db.Column(db.Date)
    active = db.Column(db.Boolean)
    in_stock = db.Column(db.Boolean)
    invisible = db.Column(db.Boolean, default=False)
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship('Image',
                                foreign_keys=thumbnail_id,
                                backref=db.backref('cultivar', uselist=False))
    images = db.relationship('Image',
                             secondary=cultivars_to_images,
                             backref='cultivars')

    def __init__(self,
                 name=None,
                 common_name=None,
                 series=None,
                 botanical_name=None,
                 description=None,
                 new_for=None,
                 active=None,
                 in_stock=None,
                 invisible=None):
        """Create an instance of Cultivar.

        Note:
            `images` and `thumbnail` have been left out because in practice
            they should have some work done to ensure they are set correctly.
        """
        self.name = name
        self.common_name = common_name
        self.series = series
        self.botanical_name = botanical_name
        self.description = description
        self.new_for = new_for
        if active is not None:
            self.active = active
        if in_stock is not None:
            self.in_stock = in_stock
        if invisible is not None:
            self.invisible = invisible

    def __repr__(self):
        """Return representation of Cultivar in human-readable format."""
        return '<{0} \'{1}\'>'.format(self.__class__.__name__,
                                      self.fullname)

    @property
    def name_with_series(self):
        """str: contents of _name with series.name included in its position."""
        if self.series:
            #  While some seed names list the series after the name of the
            #  cultivar, such as 'Violet Queen Cleome' and 'Rose Queen Cleome',
            #  mixes in these series list the series name before 'Mix', so
            #  the mix of the Queen series is 'Queen Mix Cleome' rather than
            #  'Mix Queen Cleome'.
            if (self.series.position != Series.AFTER_CULTIVAR or
                    self.name.lower() == 'mix'):
                return '{0} {1}'.format(self.series.name, self.name)
            else:
                return '{0} {1}'.format(self.name, self.series.name)
        else:
            return self.name

    @property
    def fullname(self):
        """str: Full name of cultivar including common name and series."""
        fn = []
        if self.name_with_series:
            fn.append(self.name_with_series)
        if self.common_name and self.common_name.name != self.name:
            fn.append(self.common_name.name)
        if fn:
            return ' '.join(fn)
        else:
            return None

    @property
    def queryable_dict(self):
        """dict: A dict with name, common_name, series, and index of `self`.

        Note:
            Any or all values can be `None`, as passing <obj.attribute> == None
            to db.Model.query.filter() will return `None` if no objects in the
            database have the attribute in question set to `None`. A `dict`
            with all values set to `None` won't raise an exception when used
            for a query, it will just yield no results.
        """
        name = self.name
        common_name = self.common_name.name if self.common_name else None
        index = (self.common_name.index.name if self.common_name
                 and self.common_name.index else None)
        series = self.series.name if self.series else None
        return {
            'Cultivar Name': name,
            'Common Name': common_name,
            'Index': index,
            'Series': series
        }

    @classmethod
    def from_queryable_values(cls, name, common_name, index, series=None):
        """Query a `Cultivar` from the database given its core values.

        The core values of a `Cultivar` are its name, its common name, the
        index it belongs to, and optionally the series it is in.

        Args:
            name: The name of the cultivar, not including series or common
                name.
            common_name: The common name of the cultivar.
            index: The index the cultivar's common name (and thus the cultivar
                itself) falls under.
            series: The (optional) series a cultivar is in, if applicable.

        Returns:
            Cultivar: A discrete instance of `Cultivar`.
            None: If no cultivar exists with the given parameters.
        """
        if series:
            return cls.query\
                .join(CommonName, CommonName.id == cls.common_name_id)\
                .join(Index, Index.id == CommonName.index_id)\
                .join(Series, Series.id == Cultivar.series_id)\
                .filter(cls.name == name,
                        CommonName.name == common_name,
                        Index.name == index,
                        Series.name == series)\
                .one_or_none()
        else:
            return cls.query\
                .join(CommonName, CommonName.id == cls.common_name_id)\
                .join(Index, Index.id == CommonName.index_id)\
                .filter(cls.name == name,
                        cls.series_id == None,  # noqa
                        CommonName.name == common_name,
                        Index.name == index)\
                .one_or_none()

    @classmethod
    def from_queryable_dict(cls, d):
        """Query a `Cultivar` from db given its core values in a dict.

        Args:
            d: A dictionary containing the necessary values to query a discrete
                `Cultivar` from the database.

        Returns:
            Cultivar: A discrete instance of `Cultivar`.
            None: If no `Cultivar` exists with the given parameters.
        """
        return cls.from_queryable_values(name=d['Cultivar Name'],
                                         common_name=d['Common Name'],
                                         index=d['Index'],
                                         series=d['Series'])

    def generate_slug(self):
        """Generate a string for use in URLs for pages that use `Cultivar`."""
        # Use `name_with_series` instead of `fullname` because the slug for
        # a `Cultivar` is only needed on pages where the slug for `CommonName`
        # has been passed to the view function.
        return slugify(self.name_with_series)


@event.listens_for(Cultivar, 'before_insert')
@event.listens_for(Cultivar, 'before_update')
def before_cultivar_insert_or_update(mapper, connection, target):
    """Update a `Cultivar` before flushing changes to the database."""
    target.name = dbify(target.name)
    target.slug = target.generate_slug()


class Packet(db.Model):
    """Table for seed packet information.

    Packet information includes data for each individual type of packet we
    sell, such as the size and price of a given packet. Each seed can have
    multiple different associated packets, due to different sizes (such as
    jumbo) and prices associated with different packet sizes.

    Attributes:
        sku: Product SKU for the packet.
        price: Price (in US dollars) for this packet.
        quantity: MtO relationship with `Quantity`; the quantity (including
            units of measurement) of seeds in a `Packet`.
            Backref: `Quantity.packets`
        cultivar: MtO relationship with `Cultivar`; the cultivar a `Packet`
            belongs to.
            Backref: `Cultivar.packets`
    """
    __tablename__ = 'packets'
    id = db.Column(db.Integer, primary_key=True)
    sku = db.Column(db.String(32), unique=True)
    price = db.Column(USDollar)
    quantity_id = db.Column(db.Integer, db.ForeignKey('quantities.id'))
    quantity = db.relationship('Quantity', backref='packets')
    cultivar_id = db.Column(db.Integer, db.ForeignKey('cultivars.id'))
    cultivar = db.relationship('Cultivar', backref='packets')

    def __repr__(self):
        return '<{0} SKU #{1}>'.format(self.__class__.__name__, self.sku)

    def __init__(self, sku=None, price=None, quantity=None, cultivar=None):
        """Create an instance of Packet.
        """
        self.sku = sku
        self.price = price
        if quantity:
            self.quantity = quantity
        if cultivar:
            self.cultivar = cultivar

    @property
    def info(self):
        """str: A formatted string containing the data of this packet."""
        if self.quantity:
            qv = self.quantity.value
            qu = self.quantity.units
        else:
            qv = None
            qu = None
        return 'SKU #{0}: ${1} for {2} {3}'.format(self.sku,
                                                   self.price,
                                                   qv,
                                                   qu)


class Quantity(db.Model):
    """Table for quantities.

    A Quantity consists of a numerical value and a unit of measurement. Since
    some numerical values may be integers, some may be fractions, and some may
    be decimal numbers, all numerical values are stored in internal use
    attributes `_numerator`, `_denominator`, and `_float`. Integers and
    fractions are returned using `_numerator` and `_denominator` (since a
    fraction with a denominator of 1 is an integer) while decimal numbers are
    specified by setting `is_decimal` to True, and utilize `_float` to return
    the value.

    Attributes:
        is_decimal: Whether or not the stored quantity represents a
            decimal number, as opposed to fraction or integer.
        units: Unit of measurement of a quantity. (seeds, grams, etc.)

        packets: Backref from `Packet.quantity`.
    """
    __tablename__ = 'quantities'
    id = db.Column(db.Integer, primary_key=True)
    __table_args__ = (db.UniqueConstraint('_float',
                                          'units',
                                          'is_decimal',
                                          name='_float_units_uc'),)
    _numerator = db.Column(db.Integer)
    _denominator = db.Column(db.Integer)
    _float = db.Column(db.Float)
    is_decimal = db.Column(db.Boolean, default=False)
    units = db.Column(db.String(32))

    def __init__(self, value=None, units=None):
        if value:
            self.value = value
        if units:
            self.units = units

    def __repr__(self):
        return '<{0} \'{1} {2}\'>'.format(self.__class__.__name__,
                                          self.value,
                                          self.units)

    @property
    def html_value(self):
        """str: A string of `self.value` w/ fractions in HTML if applicable."""
        if isinstance(self.value, Fraction):
            if self.value == Fraction(1, 4):
                return '&frac14;'
            elif self.value == Fraction(1, 2):
                return '&frac12;'
            elif self.value == Fraction(3, 4):
                return '&frac34;'
            elif self.value == Fraction(1, 3):
                return '&#8531;'
            elif self.value == Fraction(2, 3):
                return '&#8532;'
            elif self.value == Fraction(1, 5):
                return '&#8533;'
            elif self.value == Fraction(2, 5):
                return '&#8534;'
            elif self.value == Fraction(3, 5):
                return '&#8535;'
            elif self.value == Fraction(4, 5):
                return '&#8536;'
            elif self.value == Fraction(1, 6):
                return '&#8537;'
            elif self.value == Fraction(5, 6):
                return '&#8538;'
            elif self.value == Fraction(1, 8):
                return '&#8539;'
            elif self.value == Fraction(3, 8):
                return '&#8540;'
            elif self.value == Fraction(5, 8):
                return '&#8541;'
            elif self.value == Fraction(7, 8):
                return '&#8542;'
            else:
                return '<span class="fraction"><sup>{0}</sup>&frasl;'\
                    '<sub>{1}</sub></span>'.format(self._numerator,
                                                   self._denominator)
        return str(self.value)

    @staticmethod
    def dec_check(val):
        """Check if a given value is a decimal number.

        Args:
            val: A value to check the (perfectly cromulent) decimalness of.

        Returns:
            True: If value appears to be a decimal number.
            False: If value can't be determined to be a decimal number.

        Examples:
            >>> Quantity.dec_check(3.14)
            True

            >>> Quantity.dec_check(42)
            False

            >>> Quantity.dec_check('3.50')
            True

            >>> Quantity.dec_check('tree fiddy')
            False

            >>> Quantity.dec_check('8675309')
            False

            >>> Quantity.dec_check(Decimal('1.99'))
            True

            >>> Quantity.dec_check(Fraction(3, 4))
            False

            >>> Quantity.dec_check('127.0.0.1')
            False
        """
        if isinstance(val, Decimal) or isinstance(val, float):
            return True
        if isinstance(val, Fraction):
            return False
        try:
            float(val)
            try:
                int(val)
                return False
            except:
                return True
        except:
            return False

    @staticmethod
    def fraction_to_str(val):
        """Convert a Fraction to a string containing a mixed number.

        Args:
            val: A fraction to convert to a string fraction or
                mixed number.

        Returns:
            str: A string containing a fraction or mixed number.

        Raises:
            TypeError: If given a non-Fraction value.

        Examples:
            >>> Quantity.fraction_to_str(Fraction(1, 2))
            '1/2'

            >>> Quantity.fraction_to_str(Fraction(11, 4))
            '2 3/4'

            >>> Quantity.fraction_to_str(Fraction(123, 11))
            '11 2/11'
        """
        if isinstance(val, Fraction):
            if val.numerator > val.denominator:
                whole = val.numerator // val.denominator
                part = Fraction(val.numerator % val.denominator,
                                val.denominator)
                return '{0} {1}'.format(whole, part)
            else:
                return str(val)
        else:
            raise TypeError('val must be of type Fraction')

    @staticmethod
    def to_float(val):
        """Convert a value into a float as would be stored in `_float`.

        Args:
            val: Value to convert to a float.

        Returns:
            float: The converted value.
        """
        if Quantity.dec_check(val):
            return float(val)
        elif isinstance(val, str):
            frac = Quantity.str_to_fraction(val)
        else:
            frac = Fraction(val)
        return float(frac)

    @staticmethod
    def str_to_fraction(val):
        """Convert a string containing a number into a fraction.

        Args:
            val: A string containing a fraction or mixed number to convert
                to a `Fraction`.

        Returns:
            Fraction

        Raises:
            TypeError: If val is not a string.
            ValueError: If val could not be converted to Fraction.

        Examples:
            >>> Quantity.str_to_fraction('5')
            Fraction(5, 1)

            >>> Quantity.str_to_fraction('3/4')
            Fraction(3, 4)

            >>> Quantity.str_to_fraction('11 2/11')
            Fraction(123, 11)

            >>> Quantity.str_to_fraction('1.1')
            Fraction(11, 10)
        """
        val = val.strip()
        try:
            return Fraction(val)
        except:
            if ' ' in val:
                parts = val.split(' ')
                if len(parts) == 2 and '/' in parts[1]:
                    try:
                        whole = int(parts[0])
                        frac = Fraction(parts[1])
                        return frac + whole
                    except:
                        pass
        raise ValueError('value {0} of type {1} could not be converted to '
                         'Fraction'.format(val, type(val)))

    @classmethod
    def from_queryable_values(cls, value, units):
        """Query a Quantity from the database given its value and units."""
        return cls.query\
            .filter(cls.value == value,
                    cls.units == units,
                    cls.is_decimal == cls.dec_check(value))\
            .one_or_none()

    @hybrid_property
    def value(self):
        """"int, float, Fraction: The value of a quantity in the same format
                it was entered.

            Setter:
                Convert value a Fraction, store its numerator and denominator,
                and store a floating point version to allow querying based on
                quantity value. Flag is_decimal if the initial value is a
                decimal (floating point) number.
        """
        if self._float is not None:
            if self.is_decimal:
                return self._float
            elif self._denominator == 1:
                return self._numerator
            else:
                return Fraction(self._numerator, self._denominator)
        else:
            return None

    class ValueComparator(Comparator):
        """Comparator for `Quantity.value`.

        This comparator allows using values in queries in human-readable form,
        as they would be entered when setting `value` for an instance of
        `Quantity`. This way users do not have to convert values to float or
        worry about what kind of number the value is.
        """
        def operate(self, op, other):
            """Check a value in a query filter.

            Since `_float` and `is_decimal` are needed to retrieve the Quantity
            instance with the correct value, a filter using `value` needs check
            whether or not a `value` is a decimal number, and convert it to a
            float in order to compare it to `_float` and `is_decimal`. Luckily
            since `is_decimal` is just a boolean value, using == to check
            against it is perfectly fine regardless of what operator is being
            used to check `value`.
            """
            return and_(op(Quantity._float, Quantity.to_float(other)),
                        Quantity.is_decimal == Quantity.dec_check(other))

    @value.comparator
    def value(cls):
        return Quantity.ValueComparator(cls)

    @value.setter
    def value(self, val):
        if val is not None:
            if Quantity.dec_check(val):
                self.is_decimal = True
                self._float = float(val)
                self._numerator = None
                self._denominator = None
            else:
                self.is_decimal = False
                if isinstance(val, str):
                    frac = Quantity.str_to_fraction(val)
                else:
                    frac = Fraction(val)
                self._numerator = frac.numerator
                self._denominator = frac.denominator
                self._float = float(frac)
        else:
            self.is_decimal = None
            self._numerator = None
            self._denominator = None
            self._float = None

    @property
    def str_value(self):
        if isinstance(self.value, Fraction):
            return self.fraction_to_str(self.value)
        else:
            return str(self.value)


@event.listens_for(Packet.quantity, 'set')
def delete_orphaned_quantity(target, value, oldvalue, initiatior):
    """Delete quantities that no longer have packets associated with them."""
    if hasattr(oldvalue, 'packets') and len(oldvalue.packets) <= 1:
        if target in oldvalue.packets or not oldvalue.packets:
            db.session.delete(oldvalue)


class Synonym(db.Model):
    """Table for synonyms of other objects.

    Attributes:
        name: The synonym itself.
        common_name: MtO relationship with `CommonName`; a common name this is
            a synonym of.
            Backref: `CommonName.synonyms`
        botanical_name: MtO relationship with `BotanicalName`; a botanical name
            this is a synonym of.
            Backref: `BotanicalName.synonyms`
        cultivar: MtO relationship with `Cultivar`; the cultivar this is a
            synonym of.
            Backref: `Cultivar.synonyms`
    """
    __tablename__ = 'synonyms'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64))
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship('CommonName', backref='synonyms')
    botanical_name_id = db.Column(db.Integer,
                                  db.ForeignKey('botanical_names.id'))
    botanical_name = db.relationship('BotanicalName', backref='synonyms')
    cultivar_id = db.Column(db.Integer, db.ForeignKey('cultivars.id'))
    cultivar = db.relationship('Cultivar', backref='synonyms')

    def __init__(self, name=None):
        self.name = name

    def __repr__(self):
        """Return string representing a synonym."""
        if self.parent:
            return('<{0} \'{1}\' of {2}: \'{3}\'>'
                   .format(self.__class__.__name__,
                           self.name,
                           None if not self.parent else
                           self.parent.__class__.__name__,
                           None if not self.parent else self.parent.name))
        else:
            return('<{0} \'{1}\'>'.format(self.__class__.__name__, self.name))

    @property
    def parent(self):
        """object: Return whatever object this synonym is linked to.

        Note:
            Validation of whether or not a synonym is only linked to one
            object is handled by this property as well, as it needs to check
            validity anyway to ensure it returns the correct value. Rather
            than using a separate validation method, the best way to validate
            a `Synonym` is just to try to access `Synonym.parent`.
        """
        parents = []
        if self.common_name:
            parents.append(self.common_name)
        if self.botanical_name:
            parents.append(self.botanical_name)
        if self.cultivar:
            parents.append(self.cultivar)
        if len(parents) == 0:
            return None
        if len(parents) == 1:
            return parents.pop()
        else:
            raise ValueError(
                'Each synonym should only be linked to one other table, but '
                'this one is linked to: {0}'
                .format(', '.join([obj.__repr__() for obj in parents]))
            )


@event.listens_for(Synonym, 'before_insert')
@event.listens_for(Synonym, 'before_update')
def before_synonym_insert_or_update(mapper, connection, target):
    """Run tasks needed before flushing a `Synonym` to the database."""
    # Since Synonym has multiple possible relationships, but each synonym
    # should only correspond to one object, we need to ensure a Synonym only
    # has one relationship set before flushing it to the database.
    #
    # Simply running the Synonym.parent property will raise an appropriate
    # exception if more than one relationship is set.
    target.parent


class CustomPage(db.Model):
    """Table for custom pages that cover edge cases.

    Since there will always be some edge cases in which we may want to create
    pages that can't easily be automatically generated (for example, a page
    that lists cultivars from multiple common names) this table allows for
    generic pages to be made.

    Attributes:
        title: Page title to be used in <title> and for queries.
        content: The HTML content of the page, including parseable tokens.
        cultivars: MtM relationship with `Cultivar`; cultivars that should be
            listed on the custom page.
            Backref: `Cultivar.custom_pages`
    """
    __tablename__ = 'custom_pages'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(64), unique=True)
    content = db.Column(db.Text)
    cultivars = db.relationship('Cultivar',
                                secondary=cultivars_to_custom_pages,
                                backref='custom_pages')


class Image(db.Model):
    """Table for image information.

    Any image uploaded to be used with the cultivar model should utilize this
    table for important image data like filename and location.

    Attributes:
        filename: File name of an image.

        cultivar: Backref from `Cultivar.thumbnail`.
        cultivars: Backref from `Cultivar.images`.
    """
    __tablename__ = 'images'
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(32), unique=True)

    def __init__(self, filename=None):
        self.filename = filename

    def __repr__(self):
        return '<{0} filename: \'{1}\'>'.format(self.__class__.__name__,
                                                self.filename)

    @property
    def path(self):
        """str: The path to the image file relative to the static folder."""
        return os.path.join('images', self.filename)

    @property
    def full_path(self):
        """str: The full path to the file this image entry represents."""
        return os.path.join(current_app.config.get('IMAGES_FOLDER'),
                            self.filename)

    def delete_file(self):
        """Deletes the image file associated with this Image object."""
        os.remove(self.full_path)

    def exists(self):
        """Check whether or not file associated with this Image exists."""
        return os.path.exists(self.full_path)

    def add_postfix(self, postfix):
        """Rename an image to add a postfix to it.

        Usually this would be used for when an image with the same filename is
        added, thus allowing the old one to be renamed instead of overwritten.
        """
        old_path = self.full_path
        parts = os.path.splitext(self.filename)
        self.filename = parts[0] + postfix + parts[1]
        os.rename(old_path, self.full_path)


@event.listens_for(Image, 'before_delete')
def delete_image_file_before_delete(mapper, connection, target):
    """Delete image file of `Image` instance before the instance is deleted."""
    try:
        target.delete_file()
    except FileNotFoundError:
        print(target.full_path)
        pass  # If the file doesn't exist, there's no need to delete it.


if __name__ == '__main__':  # pragma: no cover
    import doctest
    doctest.testmod()
