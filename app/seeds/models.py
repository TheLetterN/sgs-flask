# -*- coding: utf-8 -*-
# This file is part of SGS-Flask.

# SGS-Flask is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# SGS-Flask is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Copyright Swallowtail Garden Seeds, Inc


"""
app.seeds.models

This module contains SQLAlchemy declarative models for product (seeds)
information, along with functions that assist in working with the data in
the models. Each model class represents a table in the database used by this
application.

There are some shorthand terms that are used in docs in this module, and in
naming instances of models throughout the rest of sgs_flask.

Notes:
    Shorthand:

    In the docs, these shorthand terms are used to describe relationships:
        OtM - One to Many
        MtO - Many to One
        MtM - Many to Many
        OtO - One to One

    When creating instances of various models, it is often easier to use
    shorthand versions of their names, which are typically created by removing
    as many characters from the name as possible while still keeping it
    distinct and (hopefully) fairly obvious. The most common ones:
        idx - Index
        cn - CommonName
        bn - BotanicalName
        sr - Series
        cv - Cultivar
        pkt - Packet
        qty - Quantity

    Common Attributes Not Documented in Class Docstrings:

    All models contain the attributes __tablename__ and id, but they're not
    documented in each model, as they're fairly straightforward and obvious if
    one is familiar with SQLAlchemy. Just in case, though, here's what they
    are:
        __tablename__: The name of the table. This usually corresponds to the
            name of the model itself, eg the tablename for Index is 'indexes'.
        id: An integer used as the primary key for a model. It is automatically
            generated by SQLAlchemy when a new model instance is flushed to the
            database. While it's (usually) okay to set this value manually in
            tests, it should *never* be set manually in production code, as
            each id must be unique!

    Any attribute ending in _id is a foreign key used to create a relationship
    between two tables. In MtO and OtM relationships it will be defined right
    before the relationship it's for, and it will be named <relationship>_id.
    In MtM relationships, it will be specified in the appropriate association
    table.

"""

import json
import os
from decimal import Decimal, ROUND_DOWN

from flask import current_app
from fractions import Fraction
from inflection import pluralize
from slugify import slugify
from sqlalchemy import event, inspect
from sqlalchemy.ext.hybrid import Comparator, hybrid_property
from sqlalchemy.sql.expression import and_
from flask_sqlalchemy import SignallingSession

from app import db, dbify


# Association Tables
botanical_names_to_common_names = db.Table(
    'botanical_names_to_common_names',
    db.Model.metadata,
    db.Column('botanical_names_id',
              db.Integer,
              db.ForeignKey('botanical_names.id')),
    db.Column('common_names_id', db.Integer, db.ForeignKey('common_names.id'))
)


cns_to_gw_cns = db.Table(
    'cns_to_gw_cns',
    db.Model.metadata,
    db.Column('common_name_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('gw_common_name_id',
              db.Integer,
              db.ForeignKey('common_names.id'))
)


gw_common_names_to_gw_cultivars = db.Table(
    'gw_common_names_to_gw_cultivars',
    db.Model.metadata,
    db.Column('common_names_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('cultivars_id', db.Integer, db.ForeignKey('cultivars.id'))
)


cultivars_to_gw_cultivars = db.Table(
    'cultivars_to_gw_cultivars',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('gw_cultivar_id', db.Integer, db.ForeignKey('cultivars.id'))
)


cultivars_to_custom_pages = db.Table(
    'cultivars_to_custom_pages',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('custom_pages_id', db.Integer, db.ForeignKey('custom_pages.id'))
)

cultivars_to_images = db.Table(
    'cultivars_to_images',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


# Module-level Functions
def indexes_to_json(indexes):
    """Return a list of tuples containing Index headers and slugs.

    This way we can dump needed Index information into a JSON file so we don't
    have to query the database every time we load a page with the nav bar on
    it.
    """
    return json.dumps({idx.id: (idx.header, idx.slug) for idx in indexes})


def save_indexes_to_json_file():
    """Save all indexes the file specified by ``INDEXES_JSON_FILE``"""
    with open(current_app.config.get('INDEXES_JSON_FILE'),
              'w',
              encoding='utf-8') as ofile:
        ofile.write(indexes_to_json(Index.query.all()))


# Helper Classes
class SynonymsMixin(object):
    """A mixin class to easily interact with synonyms in child classes."""
    @property
    def synonyms_string(self):
        """str: A list of Synonyms for the parent object.

        The setter parses a string list of synonyms and adds loaded or created
        synonyms to the object's synonyms. If a falsey value is set, it removes
        all synonyms from the object and deletes any synonyms which no longer
        belong to any object.
        """
        if self.synonyms:
            return ', '.join([syn.name for syn in self.synonyms])
        else:
            return ''

    @synonyms_string.setter
    def synonyms_string(self, synonyms):
        db_changed = False
        syns = synonyms.split(', ') if synonyms else []
        for syn in list(self.synonyms):
            if syn.name not in syns:
                self.synonyms.remove(syn)
                if inspect(syn).persistent:
                    db_changed = True
                    db.session.delete(syn)
        for syn in syns:
            if syn.isspace():
                syn = None
            if syn and syn not in [syno.name for syno in self.synonyms]:
                db_changed = True
                self.synonyms.append(Synonym(name=syn))
        if db_changed:
            db.session.flush()


# TypeDecorators
class USDollar(db.TypeDecorator):
    """Type for US dollar amounts to be stored in the database.

    Since we don't know for sure how the database will handle decimal numbers,
    it is safer to store our dollar amounts as integers to avoid the risk of
    floating point errors leading to incorrect data. Therfore, values will be
    stored in cents and converted back to dollars upon retrieval.

    A USDollar column will store a value of 2.99 as 299 in the database, and
    return it as 2.99 when retrieved.

    Attributes:
        impl: The type of column this decorates. Type: sqlalchemy.types.Integer
    """
    impl = db.Integer

    def process_bind_param(self, value, dialect):
        if value is None:  # pragma: no cover
            return None
        else:
            return USDollar.usd_to_cents(value)

    def process_result_value(self, value, dialect):
        if value is None:  # pragma: no cover
            return None
        else:
            return USDollar.cents_to_usd(value)

    @staticmethod
    def cents_to_usd(cents):
        """Convert a value in cents into a value in dollars.

        Args:
            cents: An integer value in cents to be converted to a decimal
                dollar value.

        Returns:
            Decimal: US cents converted to US dollars and quantized to
                always have two digits to the right of the decimal.

        Examples:
            >>> USDollar.cents_to_usd(100)
            Decimal('1.00')

            >>> USDollar.cents_to_usd(350)
            Decimal('3.50')

            >>> USDollar.cents_to_usd(2999)
            Decimal('29.99')

        """
        cents = int(cents)
        return (Decimal(cents) / 100).\
            quantize(Decimal('1.00'))

    @staticmethod
    def usd_to_decimal(usd):
        """Convert a US dollar value to a `Decimal`.

        Args:
            usd: The value to convert to `Decimal`.

        Examples:

            >>> USDollar.usd_to_decimal(3.5)
            Decimal('3.50')

            >>> USDollar.usd_to_decimal(2)
            Decimal('2.00')

            >>> USDollar.usd_to_decimal('9.99')
            Decimal('9.99')

            >>> USDollar.usd_to_decimal('$5')
            Decimal('5.00')

            >>> USDollar.usd_to_decimal('$ 4.49')
            Decimal('4.49')

            >>> USDollar.usd_to_decimal('3$')
            Decimal('3.00')
        """
        usd = str(usd).replace('$', '').strip()
        return Decimal(usd).quantize(Decimal('1.00'), rounding=ROUND_DOWN)

    @staticmethod
    def usd_to_cents(usd):
        """Convert a US dollar amount to cents.

        Args:
            usd: A US Dollar amount to convert to cents.

        Examples:

            >>> USDollar.usd_to_cents(Decimal('1.99'))
            199

            >>> USDollar.usd_to_cents(5)
            500

            >>> USDollar.usd_to_cents('$2.99')
            299

            >>> USDollar.usd_to_cents('2.5')
            250
        """
        return (int(USDollar.usd_to_decimal(usd) * 100))


# Models
class Index(db.Model):
    """Table for seed indexes.

    Indexes are the first/broadest divisions we use to sort seeds. The
    Index a seed falls under is usually based on what type of plant it is
    (herb, vegetable) or its life cycle. (perennial, annual)

    Attributes:
        name: The name for the Index itself, such as 'Herb'  or 'Perennial'.
        slug: A URL-safe version of _name.
        description: An optional HTML description of the Index.

        common_names: Backref from CommonName.index.
    """
    __tablename__ = 'indexes'
    id = db.Column(db.Integer, primary_key=True)

    # Data Required
    name = db.Column(db.String(64), unique=True)
    slug = db.Column(db.String(64), unique=True)

    # Data Optional
    description = db.Column(db.Text)

    def __init__(self, name=None, description=None):
        """Construct an instance of Index.

        Args:
            name: The name of the Index.
            description: An optional HTML description of this Index.
        """
        self.name = name
        self.description = description

    def __repr__(self):
        return '<{0} \'{1}\'>'.format(self.__class__.__name__,
                                      self.name)

    @property
    def header(self):
        """str: contents of `name` in a str for headers, titles, etc."""
        # TODO : Maybe make the string setable via config?
        return '{0} Seeds'.format(self.name)

    @property
    def plural(self):
        """str: plural form of `name`."""
        return pluralize(self.name) if self.name is not None else None

    def generate_slug(self):
        """Generate the string to use in URLs containing this `Index`."""
        return slugify(self.plural) if self.name is not None else None


@event.listens_for(Index, 'before_insert')
@event.listens_for(Index, 'before_update')
def before_index_insert_or_update(mapper, connection, target):
    """Run tasks best done before flushing an `Index` to the database."""
    target.slug = target.generate_slug()


@event.listens_for(SignallingSession, 'before_commit')
def save_indexes_json_before_commit(session):
    """Save Indexes if any have been added, edited, or deleted."""
    if any(isinstance(obj, Index) for obj in db.session):
        # It is appropriate to run `save_indexes_to_json_file` even if there
        # are deleted `Index` instances in the session, because the deleted
        # instances will not be returned by `Index.query.all()`, so deleted
        # indexes will be removed from the indexes JSON file.
        save_indexes_to_json_file()


class CommonName(SynonymsMixin, db.Model):
    """Table for common names.

    A CommonName is the next subdivision below Index in how we sort seeds.
    It is usually the common name for the species or group of species a seed
    belongs to.

    Attributes:
        index: MtO relationship with Index; the Index this CommonName falls
            under.
            Backref: Index.common_names
        name: The common name of a seed. Examples: Coleus, Tomato,
            Lettuce, Zinnia.
        slug: The URL-friendly version of this common name.

        description: An optional HTML description for this CommonName.
        instructions: Optional planting instructions for seeds with the
            specified CommonName.
        parent: An optional CommonName this is a subcategory of. For example,
            if this CommonName is 'Dwarf Coleus', it would have 'Coleus' as
            its parent. Backref: CommonName.children
        gw_common_names: MtM relationship with CommonName; an optional
            collection of CommonNames that grow well with the specified
            CommonName.
        invisible: True if the specified CommonName is to be shown on auto-
            generated pages, False if it should only be shown on custom pages
            that explicitly include it. Default value: False.

        children: Backref from CommonName.parent.
        botanical_names: Backref from BotanicalName.common_names.
        series: Backref from Series.common_name. Note: series is plural here,
            as this is the many side of the relationship.
        cultivars: Backref from Cultivar.common_name.
        gw_cultivars: Bakcref from Cultivar.gw_common_names.
    """
    __tablename__ = 'common_names'
    __table_args__ = (db.UniqueConstraint('name',
                                          'index_id',
                                          name='cn_index_uc'),)
    id = db.Column(db.Integer, primary_key=True)

    # Data Required
    index_id = db.Column(db.Integer, db.ForeignKey('indexes.id'))
    index = db.relationship('Index', backref='common_names')
    name = db.Column(db.String(64))
    slug = db.Column(db.String(64))

    # Data Optional
    description = db.Column(db.Text)
    instructions = db.Column(db.Text)
    parent_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    parent = db.relationship('CommonName',
                             backref='children',
                             foreign_keys=parent_id,
                             remote_side=[id])
    invisible = db.Column(db.Boolean, default=False)
    gw_common_names = db.relationship(
        'CommonName',
        secondary=cns_to_gw_cns,
        primaryjoin=id == cns_to_gw_cns.c.common_name_id,
        secondaryjoin=id == cns_to_gw_cns.c.gw_common_name_id
    )

    def __init__(self,
                 name=None,
                 index=None,
                 description=None,
                 instructions=None,
                 parent=None,
                 invisible=None,
                 gw_cultivars=None):
        """Construct an instance of CommonName.

        Note:
            gw_common_names has been left out because it requires work to be
            set correctly.
        """
        self.name = name
        self.index = index
        self.description = description
        self.instructions = instructions
        self.parent = parent
        if invisible is not None:  # Do not override default value
            self.invisible = invisible
        if gw_cultivars:  # Can't set an SQLAlchemy collection to None
            self.gw_cultivars = gw_cultivars

    def __repr__(self):
        return '<{0} \'{1}\'>'.format(self.__class__.__name__, self.name)

    @property
    def header(self):
        """str: ._name formatted for headers and titles."""
        return '{0} Seeds'.format(self.name)

    def lookup_dict(self):
        """Return a dictionary with name and index for easy DB lookup."""
        return {
            'Common Name': self.name if self.name else None,
            'Index': self.index.name if self.index else None}

    @classmethod
    def from_lookup_dict(cls, lookup):
        name = lookup['Common Name']
        index = lookup['Index']
        if not name:
            raise ValueError('Cannot look up CommonName without a name!')
        if index:
            return cls.query\
                .join(Index, Index.id == CommonName.index_id)\
                .filter(CommonName.name == name,
                        Index.name == index).one_or_none()
        else:
            return cls.query\
                .filter(CommonName.name == name,
                        CommonName.index == None).one_or_none()  # noqa

    def generate_slug(self):
        """Generate the string to use in URLs for this `CommonName`."""
        return slugify(self.name) if self.name is not None else None


@event.listens_for(CommonName, 'before_insert')
@event.listens_for(CommonName, 'before_update')
def before_common_name_insert_or_update(mapper, connection, target):
    """Run tasks best done before flushing a `CommonName` to the database."""
    target.slug = target.generate_slug()


class BotanicalName(SynonymsMixin, db.Model):
    """Table for botanical (scientific) names of seeds.

    The botanical name is the scientific name of the species a seed belongs
    to. A correctly-formatted botanical name begins with a genus and species
    in binomial name format, or at least a genus followed by a descriptive
    comment.

    Attributes:
        name: A botanical name associated with one or more seeds. Get
            and set via the name property.
        common_names: MtM relationship with CommonName; The CommonNames this
            BotanicalName belongs to. A BotanicalName can have multiple
            CommonNames because sometimes there are multiple CommonNames for a
            species of plant, or there could be a species that falls under
            multiple Indexes, which results in multiple CommonNames with the
            same name but different Indexes.
            Backref: CommonName.botanical_names.

        cultivars: Backref from Cultivar.botanical_name.
    """
    __tablename__ = 'botanical_names'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    common_names = db.relationship(
        'CommonName',
        secondary=botanical_names_to_common_names,
        backref='botanical_names'
    )

    def __init__(self, name=None, common_names=None, synonyms=None):
        """Construct an instance of BotanicalName.

        Note:
            synonyms should be a string, not a collection of `Synonym` objects,
            as the only relevant data `Synonym` objects contain is the synonyms
            themselves.
        """
        self.name = name
        if common_names:  # Can't set collection to None
            self.common_names = common_names
        self.synonyms_string = synonyms

    def __repr__(self):
        """Return representation of BotanicalName in human-readable format.

        Returns:
            str: Representation formatted <BotanicalName '<.name>'> for
                 example: <BotanicalName 'Asclepias incarnata'>
        """
        return '<{0} \'{1}\'>'.format(self.__class__.__name__,
                                      self.name)

    @staticmethod
    def validate(botanical_name):
        """Return True if botanical_name looks like a valid botanical name.

        Since there is a lot of variation in what constitutes a valid botanical
        name, the best we can reasonably do is make sure it contains at least
        two words, and the first could be a validly formatted genus.

        Examples:
            >>> BotanicalName.validate('Asclepias incarnata')
            True

            >>> BotanicalName.validate('asclepias incarnata')
            False

            >>> BotanicalName.validate('ASCLEPIAS INCARNATA')
            False

            >>> BotanicalName.validate('Asclepias Incarnata')
            True

            >>> BotanicalName.validate('Digitalis interspecies hybrid')
            True

        Args:
            botanical_name (str): A string containing a botanical name to
                                  check for valid formatting.

        Returns:
            bool: True if botanical_name looks valid, False if it doesn't look
                valid, or if attempting to parse it raises an exception.
        """
        try:
            nomens = botanical_name.strip().split(' ')
            if len(nomens) > 1 and nomens[0] == nomens[0].capitalize():
                return True
            else:
                return False
        except:
            return False


@event.listens_for(BotanicalName, 'before_insert')
@event.listens_for(BotanicalName, 'before_update')
def before_botanical_name_insert_or_update(mapper, connection, target):
    """Run tasks best run before adding a `BotanicalName` to the database."""
    # Validating `BotanicalName.name` should always be handled at the highest
    # level possible. Generally, this is either when a user inputs a name, or
    # a name is loaded from a file. This check exists so that failures to
    # validate `BotanicalName.name` before attempting to add it to the database
    # are caught.
    #
    # This exception should **never** be raised in production code!
    if not BotanicalName.validate(target.name):
        raise ValueError('An attempt to insert an invalid BotanicalName into '
                         'the database has occurred! Please ensure the name '
                         'of any new or edited BotanicalName is validated '
                         'before attempting to flush it to the database. You '
                         'can use BotanicalName.validate(name) to check '
                         'whether or not a name is valid.')


class Series(db.Model):
    """Table for seed series.

    A series is an optional subclass of a given cultivar type, usually created
    by the company that created the cultivars within the series. Examples
    include Benary's Giant (zinnias), Superfine Rainbow (coleus), and Heat
    Elite Mambo (petunias).

    Attributes:
        BEFORE_CULTIVAR: A constant integer representing that Series name
            should come before the cultivar name when displayed together.
        AFTER_CULTIVAR: A constant integer representing that Series name should
            come after the cultivar when displayed together.
        name: The name of the series.

        common_name: MtO relationship with CommonName; the common name a series
            belongs to.
            Backref: CommonName.series

        description: An HTML description of the Series.
        position: An integer representing whether the series name belongs
            before or after the cultivar name when displayed together. Default
            value is BEFORE_CULTIVAR.
    """
    __tablename__ = 'series'
    __table_args__ = (db.UniqueConstraint('name',
                                          'common_name_id',
                                          name='_series_name_cn_uc'),)
    id = db.Column(db.Integer, primary_key=True)

    # Constants
    BEFORE_CULTIVAR = 0
    AFTER_CULTIVAR = 1

    # Data Required
    name = db.Column(db.String(64))
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship('CommonName', backref='series')

    # Data Optional
    description = db.Column(db.Text)
    position = db.Column(db.Integer, default=BEFORE_CULTIVAR)

    def __init__(self,
                 name=None,
                 common_name=None,
                 description=None,
                 position=None):
        """Create an instance of a Series."""
        self.name = name
        self.common_name = common_name
        self.description = description
        if position is not None:
            self.position = position

    def __repr__(self):
        """Return a string representing a Series instance."""
        return '<{0} \'{1}\'>'.format(self.__class__.__name__, self.fullname)

    @property
    def fullname(self):
        """str: Name of `Series` with name of `CommonName`."""
        fn = []
        if self.name:
            fn.append(self.name)
        if self.common_name:
            fn.append(self.common_name.name)
        if fn:
            return ' '.join(fn)
        else:
            return None


class Cultivar(SynonymsMixin, db.Model):
    """Table for cultivar data.

    A cultivar is an individual variety of plant, and represents the most
    specific category seeds fall under. This is the primary attribute that
    products (Packets) are attached to.

    Note:
        A Cultivar must have a unique combination of _name, common_name, and
        series, otherwise it could result in multiple results from a query
        intended to fetch only one Cultivar. Series can be None, as long as
        the Cultivar is still a unique combination. For example, Polkadot Petra
        Foxglove and Petra Foxglove (if it existed) would qualify as unique due
        to one having a series and the other not, even though they have the
        same _name and CommonName.

    Attributes:
        name: The part of the cultivar's name that is specific to the cultivar
            itself, e.g. if a cultivar is called "Foxy Foxglove", _name will be
            "Foxy".
        slug: A URL-friendly version of _name.
        common_name: MtO relationship with CommonName; the common name a
            cultivar falls under.
            Backref: CommonName.cultivars

        series: MtO relationship with Series; the (optional) Series a Cultivar
            belongs to. While it is optional, it must be used in queries for
            Cultivars to ensure a unique result. Queries for Cultivars that
            are not in a Series should include Cultivar.series == None in the
            filter. (Note: == is used instead of is due to sqlalchemy treating
            == None as is in filters.)
            Backref: Series.cultivars
        botanical_name: MtO relationship with BotanicalName; the botanical name
            this cultivar falls under.
            Backref: BotanicalName.cultivars
        description: An optional HTML description of a Cultivar.
        new_for: An optional year for which a cultivar is new.
        active: True if the Cultivar's stock is being actively replenished,
            False if not.
        in_stock: True if a cultivar is in stock, False if not.
        invisible: Whether or not this cultivar should be listed in
            automatically generated pages. Cultivars set to invisible can still
            be listed on custom pages.
        gw_common_names: MtM relationship with CommonName; CommonNames this
            Cultivar grows well with.
            Backref: CommonName.gw_cultivars
        gw_cultivars: MtM relationship with Cultivar; Cultivars this Cultivar
            grows well with.
        thumbnail: OtO relationship with Image; thumbnail data for this
            Cultivar.
            Backref: Image.cultivar
        images: Images associated with this cultivar.
    """
    __tablename__ = 'cultivars'
    id = db.Column(db.Integer, primary_key=True)
    __table_args__ = (db.UniqueConstraint('name',
                                          'common_name_id',
                                          'series_id',
                                          name='_cultivar_name_cn_series_uc'),)

    # Data Required
    name = db.Column(db.String(64))
    slug = db.Column(db.String(64))
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship('CommonName', backref='cultivars')

    # Data Optional
    series_id = db.Column(db.Integer, db.ForeignKey('series.id'))
    series = db.relationship('Series', backref='cultivars')
    botanical_name_id = db.Column(db.Integer,
                                  db.ForeignKey('botanical_names.id'))
    botanical_name = db.relationship('BotanicalName',
                                     backref='cultivars')
    description = db.Column(db.Text)
    new_for = db.Column(db.Integer)
    active = db.Column(db.Boolean)
    in_stock = db.Column(db.Boolean)
    invisible = db.Column(db.Boolean, default=False)
    gw_common_names = db.relationship(
        'CommonName',
        secondary=gw_common_names_to_gw_cultivars,
        backref='gw_cultivars'
    )
    gw_cultivars = db.relationship(
        'Cultivar',
        back_populates='gw_cultivars',
        secondary=cultivars_to_gw_cultivars,
        primaryjoin=id == cultivars_to_gw_cultivars.c.cultivar_id,
        secondaryjoin=id == cultivars_to_gw_cultivars.c.gw_cultivar_id
    )
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship('Image',
                                foreign_keys=thumbnail_id,
                                backref=db.backref('cultivar', uselist=False))
    images = db.relationship('Image',
                             secondary=cultivars_to_images,
                             backref='cultivars')

    def __init__(self,
                 name=None,
                 common_name=None,
                 series=None,
                 botanical_name=None,
                 description=None,
                 new_for=None,
                 active=None,
                 in_stock=None,
                 invisible=None,
                 gw_common_names=None):
        """Create an instance of Cultivar.

        Note:
            `gw_cultivars`, `images`, and `thumbnail` have been left out
            because in practice they should have some work done to ensure they
            are set correctly.
        """
        self.name = name
        self.common_name = common_name
        self.series = series
        self.botanical_name = botanical_name
        self.description = description
        self.new_for = new_for
        if active is not None:
            self.active = active
        if in_stock is not None:
            self.in_stock = in_stock
        if invisible is not None:
            self.invisible = invisible
        if gw_common_names:  # collection will break if set to None
            self.gw_common_names = gw_common_names

    def __repr__(self):
        """Return representation of Cultivar in human-readable format."""
        return '<{0} \'{1}\'>'.format(self.__class__.__name__,
                                      self.fullname)

    @property
    def name_with_series(self):
        """str: contents of _name with series.name included in its position."""
        if self.series:
            #  While some seed names list the series after the name of the
            #  cultivar, such as 'Violet Queen Cleome' and 'Rose Queen Cleome',
            #  mixes in these series list the series name before 'Mix', so
            #  the mix of the Queen series is 'Queen Mix Cleome' rather than
            #  'Mix Queen Cleome'.
            if (self.series.position != Series.AFTER_CULTIVAR or
                    self.name.lower() == 'mix'):
                return '{0} {1}'.format(self.series.name, self.name)
            else:
                return '{0} {1}'.format(self.name, self.series.name)
        else:
            return self.name

    @property
    def fullname(self):
        """str: Full name of cultivar including common name and series."""
        fn = []
        if self.name_with_series:
            fn.append(self.name_with_series)
        if self.common_name and self.common_name.name != self.name:
            fn.append(self.common_name.name)
        if fn:
            return ' '.join(fn)
        else:
            return None

    @property
    def queryable_dict(self):
        """dict: A dict with name, common_name, series, and index of `self`.

        Note:
            Any or all values can be `None`, as passing <obj.attribute> == None
            to db.Model.query.filter() will return `None` if no objects in the
            database have the attribute in question set to `None`. A `dict`
            with all values set to `None` won't raise an exception when used
            for a query, it will just yield no results.
        """
        name = self.name
        common_name = self.common_name.name if self.common_name else None
        index = (self.common_name.index.name if self.common_name
                 and self.common_name.index else None)
        series = self.series.name if self.series else None
        return {
            'Cultivar Name': name,
            'Common Name': common_name,
            'Index': index,
            'Series': series
        }

    @classmethod
    def from_queryable_dict(cls, qd):
        """Load a `Cultivar` given the names of its core components in a dict.

        Args:
            qd: A dictionary either created by `Cultivar.queryable_dict` or
                with the same keys as one.
        """
        name = dbify(qd['Cultivar Name'])
        common_name = dbify(qd['Common Name'])
        index = dbify(qd['Index'])
        series = dbify(qd['Series'])
        if name and common_name and index:
            if series:
                cls

    def lookup_dict(self):
        return self.queryable_dict

    @classmethod
    def from_lookup_dict(cls, lud):
        """Load a Cultivar from db based on lookup dict.

        Args:
            lud (dict): A dictionary with values to use in querying for
                a cultivar.
        """
        name = lud['Cultivar Name']
        series = lud['Series']
        common_name = lud['Common Name']
        index = lud['Index']
        return Cultivar.lookup(name, series, common_name, index)

    @classmethod
    def lookup(cls, name, series=None, common_name=None, index=None):
        """Query a Cultivar based on its name, series, and common name.

        Since cultivars don't necessarily need a series or common name (though
        they should in theory always have a common name) we need to be able to
        query for cultivars that may not have a series or common name. This
        method allows querying based on any combination of the necessary
        parameters.

        Args:
            name (str): Name of the cultivar to query.
            series (optional[str]): Name of the series, if applicable, that
                the cultivar belongs to.
            common_name (str): The common name the cultivar belongs to.
            index (str): The index the common name (and thusly cultivar)
                belongs to.
        """
        if common_name and not index:
            raise ValueError('Common name cannot be used without an index!')
        if series and common_name:
            obj = cls.query.join(CommonName,
                                 CommonName.id == Cultivar.common_name_id)\
                .join(Series, Series.id == Cultivar.series_id)\
                .join(Index, Index.id == CommonName.index_id)\
                .filter(Cultivar.name == name,
                        CommonName.name == common_name,
                        Series.name == series).one_or_none()
        elif common_name and not series:
            obj = cls.query.join(CommonName,
                                 CommonName.id == Cultivar.common_name_id)\
                .join(Index, Index.id == CommonName.index_id)\
                .filter(Cultivar.series == None,  # noqa
                        Cultivar.name == name,
                        CommonName.name == common_name,
                        Index.name == index).one_or_none()
        else:
            obj = cls.query.filter(
                Cultivar.name == name,
                Cultivar.series == None,  # noqa
                Cultivar.common_name == None  # noqa
            ).one_or_none()
        return obj

    def generate_slug(self):
        """Generate a string for use in URLs for pages that use `Cultivar`."""
        # Use `name_with_series` instead of `fullname` because the slug for
        # a `Cultivar` is only needed on pages where the slug for `CommonName`
        # has been passed to the view function.
        return slugify(self.name_with_series)


@event.listens_for(Cultivar, 'before_insert')
@event.listens_for(Cultivar, 'before_update')
def before_cultivar_insert_or_update(mapper, connection, target):
    """Update a `Cultivar` before flushing changes to the database."""
    target.slug = target.generate_slug()


class Packet(db.Model):
    """Table for seed packet information.

    Packet information includes data for each individual type of packet we
    sell, such as the size and price of a given packet. Each seed can have
    multiple different associated packets, due to different sizes (such as
    jumbo) and prices associated with different packet sizes.

    Attributes:
        __tablename__ (str): Name of the table: 'packets'
        id (int): Auto-incremented ID # for use as a primary key.
        price (USDollar): Price (in US dollars) for this packet.
        quantity_id (int): ForeignKey for quantity relationship.
        quantity (relationship): Quantity (number and units) of seeds in this
            packet.
        cultivar_id (int): ForeignKey for relationship with cultivars.
        sku (str): Product SKU for the packet.
    """
    __tablename__ = 'packets'
    id = db.Column(db.Integer, primary_key=True)
    price = db.Column(USDollar)
    quantity_id = db.Column(db.Integer, db.ForeignKey('quantities.id'))
    quantity = db.relationship('Quantity', backref='packets')
    cultivar_id = db.Column(db.Integer, db.ForeignKey('cultivars.id'))
    cultivar = db.relationship('Cultivar', backref='packets')
    sku = db.Column(db.String(32), unique=True)

    def __repr__(self):
        return '<{0} SKU #{1}>'.format(self.__class__.__name__, self.sku)

    def __init__(self, sku=None, price=None, quantity=None, units=None):
        self.sku = sku
        self.price = price
        if quantity and units:
            self.quantity = Quantity.query.filter(
                Quantity.value == quantity,
                Quantity.units == units,
                Quantity.is_decimal == Quantity.dec_check(quantity)
            ).one_or_none()
            if not self.quantity:
                self.quantity = Quantity(value=quantity, units=units)
        elif quantity or units:
            raise ValueError('Cannot set quantity without both quantity and '
                             'units.')

    @property
    def info(self):
        """str: A formatted string containing the data of this packet."""
        if self.quantity:
            qv = self.quantity.value
            qu = self.quantity.units
        else:
            qv = None
            qu = None
        return 'SKU #{0}: ${1} for {2} {3}'.format(self.sku,
                                                   self.price,
                                                   qv,
                                                   qu)


class Quantity(db.Model):
    """Table for quantities.

    Quantities contain a number and a unit of measure. Since numbers could be
    integer, decimal, or fraction, all quantities are stored as fractions
    and floats, where the floats are only used if the quantity is a decimal
    number, and for querying that needs comparison of sizes of quantity.

    Attributes:
        __tablename__ (str): The name of the table: 'quantities'
        id (int): Auto-incremented primary key ID number.
        _denominator (int): Denominator of fraction version of quantity.
        _float (float): Floating point value for decimal values and comparison.
        is_decimal (bool): Whether or not the stored quantity represents a
            decimal number, as opposed to fraction or int.
        _numerator (int): Numerator of fraction version of quantity.
        units (str): Unit of measurement of a quantity. (seeds, grams, etc.)
        __table_args__: Table-wide arguments, such as constraints.
    """
    __tablename__ = 'quantities'
    id = db.Column(db.Integer, primary_key=True)
    _denominator = db.Column(db.Integer)
    _float = db.Column(db.Float)
    is_decimal = db.Column(db.Boolean, default=False)
    _numerator = db.Column(db.Integer)
    units = db.Column(db.String(32))
    __table_args__ = (db.UniqueConstraint('_float',
                                          'units',
                                          'is_decimal',
                                          name='_float_units_uc'),)

    def __init__(self, value=None, units=None):
        if value:
            self.value = value
        if units:
            self.units = units

    def __repr__(self):
        return '<{0} \'{1} {2}\'>'.format(self.__class__.__name__,
                                          self.value,
                                          self.units)

    @staticmethod
    def dec_check(val):
        """Check if a given value is a decimal number.

        Args:
            val: A value to check the (perfectly cromulent) decimalness of.

        Returns:
            True: If value appears to be a decimal number.
            False: If value can't be determined to be a decimal number.

        Examples:
            >>> Quantity.dec_check(3.14)
            True

            >>> Quantity.dec_check(42)
            False

            >>> Quantity.dec_check('3.50')
            True

            >>> Quantity.dec_check('tree fiddy')
            False

            >>> Quantity.dec_check('8675309')
            False

            >>> Quantity.dec_check(Decimal('1.99'))
            True

            >>> Quantity.dec_check(Fraction(3, 4))
            False

            >>> Quantity.dec_check('127.0.0.1')
            False
        """
        if isinstance(val, Decimal) or isinstance(val, float):
            return True
        if isinstance(val, Fraction):
            return False
        try:
            float(val)
            try:
                int(val)
                return False
            except:
                return True
        except:
            return False

    @staticmethod
    def fraction_to_str(val):
        """Convert a Fraction to a string containing a mixed number.

        Args:
            val (Fraction): A fraction to convert to a string fraction or
                mixed number.

        Returns:
            str: A string containing a fraction or mixed number.

        Raises:
            TypeError: If given a non-Fraction value.

        Examples:
            >>> Quantity.fraction_to_str(Fraction(1, 2))
            '1/2'

            >>> Quantity.fraction_to_str(Fraction(11, 4))
            '2 3/4'

            >>> Quantity.fraction_to_str(Fraction(123, 11))
            '11 2/11'
        """
        if isinstance(val, Fraction):
            if val.numerator > val.denominator:
                whole = val.numerator // val.denominator
                part = Fraction(val.numerator % val.denominator,
                                val.denominator)
                return '{0} {1}'.format(whole, part)
            else:
                return str(val)
        else:
            raise TypeError('val must be of type Fraction')

    @staticmethod
    def for_cmp(val):
        """Convert a value into appropriate float for querying.

        Args:
            val: Value to convert to a float.

        Returns:
            float: If value is a decimal number.
        """
        if Quantity.dec_check(val):
            return float(val)
        elif isinstance(val, str):
            frac = Quantity.str_to_fraction(val)
        else:
            frac = Fraction(val)
        return float(frac)

    @staticmethod
    def str_to_fraction(val):
        """Convert a string containing a number into a fraction.

        Args:
            val (str): String containing a fraction or mixed number to convert
                to a Fraction.

        Returns:
            Fraction: Fraction of given value.

        Raises:
            TypeError: If val is not a string.
            ValueError: If val could not be converted to Fraction.

        Examples:
            >>> Quantity.str_to_fraction('5')
            Fraction(5, 1)

            >>> Quantity.str_to_fraction('3/4')
            Fraction(3, 4)

            >>> Quantity.str_to_fraction('11 2/11')
            Fraction(123, 11)

            >>> Quantity.str_to_fraction('1.1')
            Fraction(11, 10)
        """
        if isinstance(val, str):
            val = val.strip()
            try:
                return Fraction(val)
            except:
                if ' ' in val:
                    parts = val.split(' ')
                    if len(parts) == 2 and '/' in parts[1]:
                        try:
                            whole = int(parts[0])
                            frac = Fraction(parts[1])
                            return frac + whole
                        except:
                            pass
            raise ValueError('value {0} of type {1} could not be converted to '
                             'Fraction'.format(val, type(val)))
        else:
            raise TypeError('val must be a str')

    @property
    def html_value(self):
        """str: A representation of a fraction in HTML."""
        if isinstance(self.value, Fraction):
            if self.value == Fraction(1, 4):
                return '&frac14;'
            elif self.value == Fraction(1, 2):
                return '&frac12;'
            elif self.value == Fraction(3, 4):
                return '&frac34;'
            elif self.value == Fraction(1, 3):
                return '&#8531;'
            elif self.value == Fraction(2, 3):
                return '&#8532;'
            elif self.value == Fraction(1, 5):
                return '&#8533;'
            elif self.value == Fraction(2, 5):
                return '&#8534;'
            elif self.value == Fraction(3, 5):
                return '&#8535;'
            elif self.value == Fraction(4, 5):
                return '&#8536;'
            elif self.value == Fraction(1, 6):
                return '&#8537;'
            elif self.value == Fraction(5, 6):
                return '&#8538;'
            elif self.value == Fraction(1, 8):
                return '&#8539;'
            elif self.value == Fraction(3, 8):
                return '&#8540;'
            elif self.value == Fraction(5, 8):
                return '&#8541;'
            elif self.value == Fraction(7, 8):
                return '&#8542;'
            else:
                return '<span class="fraction"><sup>{0}</sup>&frasl;'\
                    '<sub>{1}</sub></span>'.format(self._numerator,
                                                   self._denominator)
        return str(self.value)

    @hybrid_property
    def value(self):
        """"int, float, Fraction: The value of a quantity in the same format
                it was entered.

            Setter:
                Convert value a Fraction, store its numerator and denominator,
                and store a floating point version to allow querying based on
                quantity value. Flag is_decimal if the initial value is a
                decimal (floating point) number.
        """
        if self._float is not None:
            if self.is_decimal:
                return self._float
            elif self._denominator == 1:
                return self._numerator
            else:
                return Fraction(self._numerator, self._denominator)
        else:
            return None

    class ValueComparator(Comparator):
        def operate(self, op, other):
            return and_(op(Quantity._float, Quantity.for_cmp(other)),
                        Quantity.is_decimal == Quantity.dec_check(other))

    @value.comparator
    def value(cls):
        return Quantity.ValueComparator(cls)

    @value.setter
    def value(self, val):
        if val is not None:
            if Quantity.dec_check(val):
                self.is_decimal = True
                self._float = float(val)
                self._numerator = None
                self._denominator = None
            else:
                self.is_decimal = False
                if isinstance(val, str):
                    frac = Quantity.str_to_fraction(val)
                else:
                    frac = Fraction(val)
                self._numerator = frac.numerator
                self._denominator = frac.denominator
                self._float = float(frac)
        else:
            self.is_decimal = None
            self._numerator = None
            self._denominator = None
            self._float = None

    @property
    def str_value(self):
        if isinstance(self.value, Fraction):
            return self.fraction_to_str(self.value)
        else:
            return str(self.value)


class Synonym(db.Model):
    """Table for synonyms of other objects."""
    __tablename__ = 'synonyms'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64))
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship('CommonName', backref='synonyms')
    botanical_name_id = db.Column(db.Integer,
                                  db.ForeignKey('botanical_names.id'))
    botanical_name = db.relationship('BotanicalName', backref='synonyms')
    cultivar_id = db.Column(db.Integer, db.ForeignKey('cultivars.id'))
    cultivar = db.relationship('Cultivar', backref='synonyms')

    def __init__(self, name=None):
        self.name = name

    def __repr__(self):
        """Return string representing a synonym."""
        if self.parent:
            return('<{0} \'{1}\' of {2}: \'{3}\'>'
                   .format(self.__class__.__name__,
                           self.name,
                           None if not self.parent else
                           self.parent.__class__.__name__,
                           None if not self.parent else self.parent.name))
        else:
            return('<{0} \'{1}\'>'.format(self.__class__.__name__, self.name))

    @property
    def parent(self):
        """Returns whatever foreign row this synonym belongs to."""
        parents = []
        if self.common_name:
            parents.append(self.common_name)
        if self.botanical_name:
            parents.append(self.botanical_name)
        if self.cultivar:
            parents.append(self.cultivar)
        if len(parents) == 0:
            return None
        if len(parents) == 1:
            return parents.pop()
        else:
            raise ValueError(
                'Each synonym should only be linked to one other table, but '
                'this one is linked to: {0}'
                .format(', '.join([obj.__repr__() for obj in parents]))
            )


class CustomPage(db.Model):
    """Table for custom pages that cover edge cases.

    Since there will always be some edge cases in which we may want to create
    pages that can't easily be automatically generated (for example, a page
    that lists cultivars from multiple common names) this table allows for
    generic pages to be made.

    Attributes:
        __tablename__ (str): Name of the table: 'custom_pages'
        id (int): Auto-incremented ID # as primary key.
        title (str): Page title to be used in <title> and for lookups.
        content (str): The HTML content of the page, including parseable
            tokens.
        cultivars (relationship): Relationship to link cultivars to custom
            pages.
            backref: custom_pages
    """
    __tablename__ = 'custom_pages'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(64), unique=True)
    content = db.Column(db.Text)
    cultivars = db.relationship('Cultivar',
                                secondary=cultivars_to_custom_pages,
                                backref='custom_pages')


class Image(db.Model):
    """Table for image information.

    Any image uploaded to be used with the cultivar model should utilize this
    table for important image data like filename and location.

    filename: File name of an image.
    """
    __tablename__ = 'images'
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(32), unique=True)

    def __init__(self, filename=None):
        self.filename = filename

    def __repr__(self):
        return '<{0} filename: \'{1}\'>'.format(self.__class__.__name__,
                                                self.filename)

    @property
    def path(self):
        """str: The path to the image file relative to the static folder."""
        return os.path.join('images', self.filename)

    @property
    def full_path(self):
        """str: The full path to the file this image entry represents."""
        return os.path.join(current_app.config.get('IMAGES_FOLDER'),
                            self.filename)

    def delete_file(self):
        """Deletes the image file associated with this Image object."""
        os.remove(self.full_path)

    def exists(self):
        """Check whether or not file associated with this Image exists."""
        return os.path.exists(self.full_path)


if __name__ == '__main__':  # pragma: no cover
    import doctest
    doctest.testmod()
