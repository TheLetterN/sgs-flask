# -*- coding: utf-8 -*-
# This file is part of SGS-Flask.

# SGS-Flask is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# SGS-Flask is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Copyright Swallowtail Garden Seeds, Inc


"""
app.seeds.models

This module contains SQLAlchemy declarative models for product (seeds)
information, along with functions that assist in working with the data in
the models. Each model class represents a table in the database used by this
application.

There are some shorthand terms that are used in docs in this module, and in
naming instances of models throughout the rest of sgs_flask.

Notes:
    Shorthand:

    In the docs, these shorthand terms are used to describe relationships:
        OtM - One to Many
        MtO - Many to One
        MtM - Many to Many
        OtO - One to One

    When creating instances of various models, it is often easier to use
    shorthand versions of their names, which are typically created by removing
    as many characters from the name as possible while still keeping it
    distinct and (hopefully) fairly obvious. The most common ones:
        idx - Index
        cn - CommonName
        bn - BotanicalName
        sec - Section
        cv - Cultivar
        pkt - Packet
        qty - Quantity

    Common Attributes Not Documented in Class Docstrings:

    All models contain the attributes __tablename__ and id, but they're not
    documented in each model, as they're fairly straightforward and obvious if
    one is familiar with SQLAlchemy. Just in case, though, here's what they
    are:
        __tablename__: The name of the table. This usually corresponds to the
            name of the model itself, eg the tablename for Index is 'indexes'.
        id: An integer used as the primary key for a model. It is automatically
            generated by SQLAlchemy when a new model instance is flushed to the
            database. While it's (usually) okay to set this value manually in
            tests, it should *never* be set manually in production code, as
            each id must be unique!

    Any attribute ending in _id is a foreign key used to create a relationship
    between two tables. In MtO and OtM relationships it will be defined right
    before the relationship it's for, and it will be named <relationship>_id.
    In MtM relationships, it will be specified in the appropriate association
    table.

    Grows With:

    Columns beginning with "gw_" represent that a CommonName or Cultivar grows
    well with other CommonNames or Cultivars. These are unidirectional
    relationships instead of bidirectional because they are used in generating
    grows with links, and we don't necessarily want A grows with B to create
    B grows with A, as it is often more important that customers know A grows
    with B than that B grows with A, so rather than clutter up pages with
    unnecessary grows with links that draw attention away from the important
    grows with links, we only want the important links to be generated.

"""

import datetime
import json
import os
import re
import shutil
import sys
from decimal import Decimal, ROUND_DOWN
from pathlib import Path

from flask import current_app, url_for
from fractions import Fraction
from inflection import pluralize
from PIL import Image as Pimage
from slugify import slugify
from titlecase import titlecase
from sqlalchemy import event, inspect
from sqlalchemy.ext.hybrid import Comparator, hybrid_property
from sqlalchemy.ext.orderinglist import ordering_list
from sqlalchemy.sql.expression import and_
from flask_sqlalchemy import SignallingSession

from app import db, list_to_english


# Association Tables
botanical_names_to_common_names = db.Table(
    'botanical_names_to_common_names',
    db.Model.metadata,
    db.Column('botanical_names_id',
              db.Integer,
              db.ForeignKey('botanical_names.id')),
    db.Column('common_names_id', db.Integer, db.ForeignKey('common_names.id'))
)


botanical_names_to_sections = db.Table(
    'botanical_names_to_sections',
    db.Model.metadata,
    db.Column('botanical_names_id',
              db.Integer,
              db.ForeignKey('botanical_names.id')),
    db.Column('sections.id', db.Integer, db.ForeignKey('sections.id'))
)


cultivars_to_custom_pages = db.Table(
    'cultivars_to_custom_pages',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('custom_pages_id', db.Integer, db.ForeignKey('custom_pages.id'))
)


cultivars_to_images = db.Table(
    'cultivars_to_images',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


cultivars_to_sections = db.Table(
    'cultivars_to_sections',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('section_id', db.Integer, db.ForeignKey('sections.id'))
)


common_names_to_gw_common_names = db.Table(
    'common_names_to_gw_common_names',
    db.Model.metadata,
    db.Column('parent_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('child_id', db.Integer, db.ForeignKey('common_names.id'))
)


common_names_to_gw_cultivars = db.Table(
    'common_names_to_gw_cultivars',
    db.Model.metadata,
    db.Column('common_name_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id'))
)

cultivars_to_gw_common_names = db.Table(
    'cultivars_to_gw_common_names',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('common_name_id', db.Integer, db.ForeignKey('common_names.id'))
)

cultivars_to_gw_cultivars = db.Table(
    'cultivars_to_gw_cultivars',
    db.Model.metadata,
    db.Column('parent_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('child_id', db.Integer, db.ForeignKey('cultivars.id'))
)

def dump_db_to_json(filename):
    """Save all data needed to copy the database into a JSON file."""
    d = dict()
    d['images'] = [i.dict_ for i in Image.query.all()]
    d['indexes'] = [i.dict_ for i in Index.query.all()]
    d['common names'] = [c.dict_ for c in CommonName.query.all()]
    d['botanical names'] = [b.dict_ for b in BotanicalName.query.all()]

    with open(filename, 'w') as outfile:
        outfile.write(json.dumps(d, indent=4))


def populate_db_from_json(filename):
    """Populate a new db with data loaded from a JSON file."""
    with open(filename, 'r') as infile:
        d = json.loads(infile.read())
    for img_d in d['images']:
        db.session.add(Image.from_dict_(img_d))
    db.session.flush()
    for idx_d in d['indexes']:
        db.session.add(Index.from_dict_(idx_d))
    db.session.flush()
    for cn_d in d['common names']:
        db.session.add(CommonName.from_dict_(cn_d))
    db.session.flush()
    for cn_d in d['common names']:
        cn = CommonName.query.get(cn_d['id'])
        cn.gw_from_dict_(cn_d)
    for bn_d in d['botanical names']:
        db.session.add(BotanicalName.query.get(bn_d['id']))
    db.session.flush()

    db.session.commit()


# Module-level Functions
def dbify(string):
    """Format a string to be stored in the database.

    Args:
        string: The string to be converted.

    Returns:
        str: A string formatted for database usage.
        None: If string is None or empty.
    """
    def cb(word, **kwargs):
        """Override default behaviors in titlecase that give incorrect results.

        Hyphenated phrases should only capitalize the first letter. The default
        behavior of titlecase is to capitalize the first letter in each part.
        e.g forget-me-not > Forget-Me-Not, while we want forget-me-not >
        Forget-me-not.

        Also some 'words' should be in all-caps, such as roman numerals, and
        if a number followed by an uppercase letter occurs, it should be
        assumed it's meant to be that way, as in Texas 1015Y Onion.

        Returns:
            str: Corrected hyphenated word.
        """
        # Some things should be allcaps, such as roman numerals.
        ALLCAPS = ('I', 'II', 'III', 'IV', 'V', 'XP', 'BLBP')
        if '-' in word:
            return word[0].upper() + word[1:].lower()
        elif word.upper() in ALLCAPS:
            return word.upper()
        elif re.search(r'[0-9][A-Za-z]', word):
            return word.upper()
        elif word.lower() == 'w/':
            return 'w/'
        elif re.search(r'[dD]\'[A-Za-z]+', word):  # d'Avignon
            parts = word.split('\'')
            parts[0] = parts[0].lower()
            parts[1] = parts[1].title()
            return '\''.join(parts)
        elif re.search(r'[oO]\'[A-Za-z]+', word):  # O'Hara
            parts = word.split('\'')
            parts[0] = parts[0].upper()
            parts[1] = parts[1].title()
            return '\''.join(parts)

    if string:
        # lower() string in addition to stripping it because titlecase()
        # leaves capital words capitalized in mixed case lines.
        # we don't want that because we want a line like:
        # 'RED FLOWER (white bee)' to become 'Red Flower (White Bee)'.
        string = string.strip().lower()
        dbified = titlecase(string, callback=cb)
        return dbified
    else:
        return None


def row_exists(col, value):
    """Check to see if a given row exists in a table.

    Args:
        col: The column to check, in the form of a db Model attribute, e.g.
            `Index.name` or `Packet.sku`.
        value: The value of the row to check for.

    Returns:
        bool: True if row exists, False if not.
    """
    return db.session.query(db.exists().where(col == value)).scalar()


# Helper Classes
class PositionableMixin(object):
    """A mixin class to provide position functionality to models.

    While positions are integer numbers, all users need to know about positions
    is how they relate to each other, so the actual numbers are arbitrary. The
    numbers can and will change as instances are added or moved around.

    Attributes:
        position: An integer column for an instance's position relative to the
            other instances of that model.
    """
    position = db.Column(db.Integer)

    @property
    def positionable_instances(self):
        """Return a list of all instances of model in both db and session.

        Note:
            This method should be overridden in child models that should be
            positioned relative to a parent instead of all instances of the
            child model. e.g. in `CommonName`, `positionable_instances` should
            return all instances of `CommonName` with the same parent `Index`.

        Returns:
            list: All active instances of the model.
        """
        cls = self.__class__
        rows = cls.query.all()
        # This will not result in every instance of every class that inherits
        # from this mixin being added to rows, as `cls` will evaluate to the
        # child class, not `PositionableMixin`.
        rows += [i for i in db.session.new if isinstance(i, cls)]
        return rows

    def clean_positions(self, remove_self=False):
        """Re-number positions to account for gaps and inconsistencies.

        Args:
            remove_self: True if the instance `self` should be removed from
                the list of active instances before cleaning. This should
                only be set to True if `self` is being moved to a different
                parent, or being deleted from the database.
        """
        rows = self.positionable_instances
        if remove_self:
            rows.pop(rows.index(self))
        if rows:
            for row in rows:
                if row.position is None:
                    row.auto_position()
            sorted_rows = sorted(rows, key=lambda x: x.position)
            for i, row in enumerate(sorted_rows, 1):
                row.position = i

    def auto_position(self):
        """Automatically position this instance.

        This should generally only be run when adding a new instance, otherwise
        it should do nothing.
        """
        if not self.position:
            last = self.last
            if last:
                self.position = last.position + 1
            else:
                self.position = 1

    def set_position(self, position):
        """Manually set position of instance, and change position of others."""
        if self.position != position:
            rows = self.positionable_instances
            pruned_rows = [r for r in rows if r.position is not None]
            if pruned_rows:
                first = min(pruned_rows, key=lambda x: x.position)
                last = max(pruned_rows, key=lambda x: x.position)
                if position < first.position:
                    position = first.position
                if position > last.position + 1:
                    position = last.position + 1
                for r in pruned_rows:
                    if r.position >= position:
                        r.position += 1
                self.position = position
                if self not in pruned_rows:
                    pruned_rows.append(self)
                pruned_rows = sorted(pruned_rows, key=lambda x: x.position)
                for i, r in enumerate(pruned_rows, 1):
                    r.position = i
            else:
                self.auto_position()

    # Navigation methods
    def _step(self, forward=True):
        """Return next or previous instance by position.

        Args:
            forward: True if getting next instance, False if previous.

        Returns:
            The next or previous instance, or None if there is no next or
            previous instance.
        """
        model = self.__class__
        cur_pos = self.position
        if forward:
            end_pos = self.last.position
        else:
            end_pos = self.first.position
        inst = None
        while inst is None:
            if cur_pos == end_pos:
                break

            if forward:
                cur_pos += 1
            else:
                cur_pos -= 1
            inst = model.query.filter(model.position == cur_pos).first()

        return inst

    @property
    def first(self):
        """Get the first instance according to position.

        Returns:
            The lowest positioned instance of <parent class>.
        """
        return min(self.positionable_instances,
                   key=lambda x: x.position,
                   default=None)

    @property
    def previous(self):
        """Get the previous instance according to position.

        Returns:
            The previous instance, or None if this instance is first.
        """
        return self._step(forward=False)

    @property
    def next(self):
        """Get the next instance according to position.

        Returns:
            The next instance, or None if this instance is last.
        """
        return self._step(forward=True)

    @property
    def last(self):
        """Get the last instance according to position.

        Returns:
            The highest positioned instance of <parent class>.
        """
        rows = self.positionable_instances
        pruned_rows = [r for r in rows if r and r.position is not None]
        return max(pruned_rows,
                   key=lambda x: x.position,
                   default=None)


class OrderingListMixin(object):
    """A mixin for methods dealing with ordering_list positioning."""
    @property
    def parent_collection(self):
        raise NotImplementedError(
            'The parent_collection property for \'{0}\' has not been '
            'implemented yet!'.format(self.__class__.__name___)
        )

    def move(self, delta):
        """Move position of object w/ respect to its parent collection.

        Args:
            delta: The number of positions to move. Positive for forward,
                negative for backwards. No matter what delta is passed, no
                `CommonName` will be moved below the lowest index or above
                the highest index.
        """
        collection = self.parent_collection
        from_index = collection.index(self)
        to_index = from_index + delta
        last_index = len(collection) - 1
        if to_index < 0:
            to_index = 0
        if to_index > last_index:
            to_index = last_index
        if from_index != to_index:
            collection.insert(to_index, collection.pop(from_index))
            return True
        else:
            return False

    def move_after(self, other):
        """Move self to position after other.

        Args:
            other: An instance of the same model to place `self` after.
        """
        self_index = self.parent_collection.index(self)
        other_index = self.parent_collection.index(other)
        # other's index will be decremented if other comes after self and
        # self is popped, so other_index will be the index after other.
        # Therefore, we only need to increment other_index if other is before
        # self.
        if other_index < self_index:
            other_index += 1
        self.parent_collection.insert(
            other_index, self.parent_collection.pop(self_index)
        )

    def insert_after(self, other):
        """Insert at index after `other`.

        Args:
            other: An instance of the same model to place `self` after.
        """
        self.parent_collection.insert(
            self.parent_collection.index(other) + 1, self
        )


class SynonymsMixin(object):
    """A mixin class to easily interact with synonyms in child classes."""
    @property
    def synonyms_string(self):
        """str: A list of Synonyms for the parent object.

        The setter parses a string list of synonyms and adds loaded or created
        synonyms to the object's synonyms. If a falsey value is set, it removes
        all synonyms from the object and deletes any synonyms which no longer
        belong to any object.
        """
        if self.synonyms:
            return ', '.join([syn.name for syn in self.synonyms])
        else:
            return ''

    @synonyms_string.setter
    def synonyms_string(self, synonyms):
        db_changed = False
        syns = synonyms.split(', ') if synonyms else []
        for syn in list(self.synonyms):
            if syn.name not in syns:
                self.synonyms.remove(syn)
                if inspect(syn).persistent:
                    db_changed = True
                    db.session.delete(syn)
        for syn in syns:
            if syn.isspace():
                syn = None
            if syn and syn not in [syno.name for syno in self.synonyms]:
                db_changed = True
                self.synonyms.append(Synonym(name=syn))
        if db_changed:
            db.session.flush()


# TypeDecorators
class USDollar(db.TypeDecorator):
    """Type for US dollar amounts to be stored in the database.

    Since we don't know for sure how the database will handle decimal numbers,
    it is safer to store our dollar amounts as integers to avoid the risk of
    floating point errors leading to incorrect data. Therfore, values will be
    stored in cents and converted back to dollars upon retrieval.

    A USDollar column will store a value of 2.99 as 299 in the database, and
    return it as 2.99 when retrieved.

    Attributes:
        impl: The type of column this decorates: `sqlalchemy.types.Integer`.
    """
    impl = db.Integer

    def process_bind_param(self, value, dialect):
        if value is None:  # pragma: no cover
            return None
        else:
            return USDollar.usd_to_cents(value)

    def process_result_value(self, value, dialect):
        if value is None:  # pragma: no cover
            return None
        else:
            return USDollar.cents_to_usd(value)

    @staticmethod
    def cents_to_usd(cents):
        """Convert a value in cents into a value in dollars.

        Args:
            cents: An integer value in cents to be converted to a decimal
                dollar value.

        Returns:
            Decimal: US cents converted to US dollars and quantized to
                always have two digits to the right of the decimal.

        Examples:
            >>> USDollar.cents_to_usd(100)
            Decimal('1.00')

            >>> USDollar.cents_to_usd(350)
            Decimal('3.50')

            >>> USDollar.cents_to_usd(2999)
            Decimal('29.99')

        """
        cents = int(cents)
        return (Decimal(cents) / 100).\
            quantize(Decimal('1.00'))

    @staticmethod
    def usd_to_decimal(usd):
        """Convert a US dollar value to a `Decimal`.

        Args:
            usd: The value to convert to `Decimal`.

        Examples:

            >>> USDollar.usd_to_decimal(3.5)
            Decimal('3.50')

            >>> USDollar.usd_to_decimal(2)
            Decimal('2.00')

            >>> USDollar.usd_to_decimal('9.99')
            Decimal('9.99')

            >>> USDollar.usd_to_decimal('$5')
            Decimal('5.00')

            >>> USDollar.usd_to_decimal('$ 4.49')
            Decimal('4.49')

            >>> USDollar.usd_to_decimal('3$')
            Decimal('3.00')
        """
        usd = str(usd).replace('$', '').strip()
        return Decimal(usd).quantize(Decimal('1.00'), rounding=ROUND_DOWN)

    @staticmethod
    def usd_to_cents(usd):
        """Convert a US dollar amount to cents.

        Args:
            usd: A US Dollar amount to convert to cents.

        Examples:

            >>> USDollar.usd_to_cents(Decimal('1.99'))
            199

            >>> USDollar.usd_to_cents(5)
            500

            >>> USDollar.usd_to_cents('$2.99')
            299

            >>> USDollar.usd_to_cents('2.5')
            250
        """
        return (int(USDollar.usd_to_decimal(usd) * 100))


# Models
class Index(db.Model, PositionableMixin):
    """Table for seed indexes.

    Indexes are the first/broadest divisions we use to sort seeds. The
    `Index` a seed falls under is usually based on what type of plant it is
    (herb, vegetable) or its life cycle. (perennial, annual)

    Attributes:
        position: An integer determining where an `Index` belongs in a list
            of `Index` instances. Inherited from `PositionableMixin`.

        name: The name for the `Index` itself, such as 'Herb'  or 'Perennial'.
        slug: A URL-safe version of `name`.

        thumbnail: An optional `Image` used as a thumbnail for a common name.
        description: An optional HTML description of the `Index`.
        common_names: Optional `CommonName` instances belonging to an `Index`.
    """
    __tablename__ = 'indexes'
    id = db.Column(db.Integer, primary_key=True)
    # position - db.Column(db.Integer) inherited from PositionableMixin

    # Data Required
    name = db.Column(db.String(64), unique=True)
    slug = db.Column(db.String(64), unique=True)

    # Data Optional
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship('Image', back_populates='indexes_with_thumb')
    description = db.Column(db.Text)
    common_names = db.relationship(
        'CommonName',
        order_by='CommonName.idx_pos',
        collection_class=ordering_list('idx_pos', count_from=1),
        back_populates='index'
    )

    def __init__(self, name=None, description=None):
        """Construct an instance of Index.

        Args:
            name: The name of the Index.
            description: An optional HTML description of this Index.
        """
        self.name = name
        self.description = description

    def __repr__(self):
        return '<{0} \'{1}\'>'.format(self.__class__.__name__,
                                      self.name)

    def __eq__(self, other):
        return all((
            self.id == other.id,
            self.position == other.position,
            self.name == other.name,
            self.slug == other.slug,
            self.description == other.description
        )) if isinstance(other, Index) else False  # other can be None.

    def __hash__(self):  # pragma: no cover
        return hash(self.id)

    @property
    def url(self):
        """Return the URL for the main page for a given `Index`."""
        return url_for('seeds.index', idx_slug=self.slug, _external=True)

    @property
    def dict_(self):
        """Return a dictionary of values needed to instantiate an `Index`.

        Note:
            Relationships with rows expected to be created after this are
            intentionally left out. They will be dealt with in their respective
            models.
        """
        return dict(
            id=self.id,
            position=self.position,
            name=self.name,
            slug=self.slug,
            thumbnail_id=self.thumbnail_id,
            description=self.description
        )

    @classmethod
    def from_dict_(cls, dict_):
        """Return a loaded or created `Index` using values from dict_.

        Note:
            This function should only be used during initial database
            population, it should not be used on a populated database!

        Args:
            dict_: A dictionary generated by `Index.dict_`.
        """
        idx = cls.query.get(dict_['id'])
        if idx:
            raise ValueError(
                'An Index with id {0} already exists as: \'{0}\''
                .format(idx.id, idx.name)
            )
        idx = cls()
        for key in dict_.keys():
            if key == 'thumbnail_id' and dict_[key] is not None:
                idx.thumbnail = Image.query.get(dict_[key])
            else:
                idx.__setattr__(key, dict_[key])
        return idx

    @classmethod
    def get_or_create(cls, name, stream=sys.stdout):
        """Load an `Index` if it exists, create it if not.

        Note:
            The boolean attribute 'created' is attached to the `Index`
                instance so we know whether the returned Index was created or
                loaded.

        Args:
            name: The name of the `Index` to query or create.
            stream: Optional IO stream to write messages to.

        Returns:
            Index: The `Index` loaded/created.
        """
        idx = cls.query.filter(cls.name == name).one_or_none()
        if idx:
            print('The Index \'{0}\' has been loaded from the database.'
                  .format(idx.name), file=stream)
            idx.created = False
        else:
            idx = cls(name=name)
            print('The Index \'{0}\' does not yet exist in the database, so '
                  'it has been created.'.format(idx.name), file=stream)
            idx.created = True
        return idx

    @property
    def header(self):
        """str: contents of `name` in a str for headers, titles, etc."""
        # TODO : Maybe make the string setable via config?
        return '{0} Seeds'.format(self.name)

    @property
    def plural(self):
        """str: plural form of `name`."""
        return pluralize(self.name) if self.name is not None else None

    def generate_slug(self):
        """Generate the string to use in URLs containing this `Index`."""
        return slugify(self.plural) if self.name is not None else None

    @classmethod
    def save_nav_json(cls, json_file=None):
        """Save a JSON file with data for use in navs.

        Args:
            json_file: Optional filename to save JSON indexes to. If not given,
                it will default to `config.JSON_FOLDER`/nav/indexes.json.
        """
        indexes = cls.query.all()
        if not json_file:
            json_file = Path(
                current_app.config.get('JSON_FOLDER'), 'nav', 'indexes.json'
            )
            if not json_file.parent.exists():
                json_file.parent.mkdir(parents=True)
            dicts = {
                idx.position if idx.position is not None else idx.id: {
                    'header': idx.header,
                    'slug': idx.slug
                } for idx in indexes
            }
        with json_file.open('w', encoding='utf-8') as ofile:
            ofile.write(json.dumps(dicts, indent=4))


@event.listens_for(Index, 'before_insert')
@event.listens_for(Index, 'before_update')
def before_index_insert_or_update(mapper, connection, target):
    """Run tasks best done before flushing an `Index` to the database."""
    target.slug = target.generate_slug()


@event.listens_for(SignallingSession, 'before_commit')
def save_indexes_json_before_commit(session):
    """Save Indexes if any have been added, edited, or deleted."""
    if any(isinstance(obj, Index) for obj in db.session):
        # It is appropriate to run `save_nav_json` even if there
        # are deleted `Index` instances in the session, because the deleted
        # instances will not be returned by `Index.query.all()`, so deleted
        # indexes will be removed from the indexes JSON file.
        Index.save_nav_json()


class CommonName(OrderingListMixin, SynonymsMixin, db.Model):
    """Table for common names.

    A `CommonName` is the next subdivision below `Index` in how we sort seeds.
    It is usually the common name for the species or group of species a seed
    belongs to.

    Attributes:
        idx_pos: The position an instance of `CommonName` has relative to other
            `CommonName` instances belonging to the same `Index`. Automatically
             set by the relationship `Index.common_names`.

        index: The `Index` a `CommonName` instance belongs to.
        name: The common name of a seed. Examples: Coleus, Tomato,
            Lettuce, Zinnia.
        slug: URL-friendly version `name`.

        thumbnail: An optional thumbnail `Image`.
        description: An optional HTML description.
        instructions: Optional planting instructions for seeds with the
            specified CommonName.
        grows_with: Other `CommonName` instances that grow well with the
            given instance.
        visible: Whether or not to list given `CommonName` on non-custom pages.
            Default value: True.
        botanical_names: `BotanicalName` belonging to given `CommonName`.
        sections: `Section` instances belonging to given `CommonName`.
        cultivars: `Cultivar` instances belonging to given `CommonName`.
        synonyms: `Synonym` instances which are synonyms of given `CommonName`.
    """
    __tablename__ = 'common_names'
    __table_args__ = (db.UniqueConstraint('name',
                                          'index_id',
                                          name='cn_name_index_uc'),
                      db.UniqueConstraint('slug',
                                          'index_id',
                                          name='cn_slug_index_uc'))
    id = db.Column(db.Integer, primary_key=True)

    # Position
    idx_pos = db.Column(db.Integer)

    # Data Required
    index_id = db.Column(db.Integer, db.ForeignKey('indexes.id'))
    index = db.relationship('Index', back_populates='common_names')
    name = db.Column(db.String(64))
    slug = db.Column(db.String(64))

    # Data Optional
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship(
        'Image',
        back_populates='common_names_with_thumb'
    )
    description = db.Column(db.Text)
    instructions = db.Column(db.Text)
    gw_common_names = db.relationship(
        'CommonName',
        secondary=common_names_to_gw_common_names,
        primaryjoin=id == common_names_to_gw_common_names.c.parent_id,
        secondaryjoin=id == common_names_to_gw_common_names.c.child_id
    )
    gw_cultivars = db.relationship(
        'Cultivar',
        secondary=common_names_to_gw_cultivars
    )
    visible = db.Column(db.Boolean)
    botanical_names = db.relationship(
        'BotanicalName',
        secondary=botanical_names_to_common_names,
        back_populates='common_names'
    )
    sections = db.relationship('Section',
            foreign_keys='Section.common_name_id',
            back_populates='common_name')
    child_sections = db.relationship(
        'Section',
        order_by='Section.cn_pos',
        collection_class=ordering_list('cn_pos', count_from=1),
        foreign_keys='Section.parent_common_name_id',
        back_populates='parent_common_name'
    )
    cultivars = db.relationship(
        'Cultivar',
        foreign_keys='Cultivar.common_name_id',
        back_populates='common_name'
    )
    child_cultivars = db.relationship(
        'Cultivar',
        order_by='Cultivar.cn_pos',
        foreign_keys='Cultivar.parent_common_name_id',
        collection_class=ordering_list('cn_pos', count_from=1),
        back_populates='parent_common_name'
    )
    synonyms = db.relationship('Synonym', back_populates='common_name')

    def __init__(self,
                 name=None,
                 index=None,
                 description=None,
                 instructions=None,
                 visible=None):  # pragma: no cover
        """Construct an instance of `CommonName`."""
        self.name = name
        self.index = index
        self.description = description
        self.instructions = instructions
        if visible is not None:  # Do not override default value
            self.visible = visible

    def __repr__(self):
        return '<{0} \'{1}\'>'.format(self.__class__.__name__, self.name)

    def __eq__(self, other):
        return all((
            self.id == other.id,
            self.index == other.index,
            self.name == other.name,
            self.slug == other.slug,
            self.description == other.description,
            self.instructions == other.instructions,
            self.gw_common_names == other.gw_common_names,
            self.gw_cultivars == other.gw_cultivars,
            self.visible == other.visible
        )) if isinstance(other, CommonName) else False

    def __hash__(self):
        return hash(self.id)

    @property
    def parent_collection(self):
        """Return the collection `CommonName` instances are ordered in."""
        if self.index:
            return self.index.common_names
        else:
            return None

    @property
    def url(self):
        return url_for(
            'seeds.common_name',
            cn_slug=self.slug,
            idx_slug=self.index.slug,
            _external=True
        )

    @property
    def link_html(self):
        return '<a href="{0}">{1}</a>'.format(self.url, self.name)

    @property
    def gw_common_names_ids(self):
        """Return list of ids of `gw_common_names`."""
        return [gwcn.id for gwcn in self.gw_common_names]

    @property
    def gw_cultivars_ids(self):
        """Return list of ids of `gw_cultivars`."""
        return [gwcv.id for gwcv in self.gw_cultivars]

    @property
    def dict_(self):
        """Return a dictionary of values needed to duplicate `CommonName`."""
        return dict(
            id=self.id,
            index_id=self.index_id,
            name=self.name,
            slug=self.slug,
            description=self.description,
            instructions=self.instructions,
            gw_common_names=[cn.id for cn in self.gw_common_names],
            gw_cultivars=[cv.id for cv in self.gw_cultivars],
            visible=self.visible
        )

    @classmethod
    def from_dict_(cls, dict_):
        """Create a new `CommonName` from a dict provided by dict_.

        Note:

        `grows_with` is NOT handled by this function, as it requires all
        `CommonName` instances already exist in the database. Use the
        `CommonName.gw_from_dict_` function to set `grows_with` after
        all `CommonName` instances have been flushed or committed to db.
        """
        cn = cls.query.get(dict_['id'])
        if cn:
            raise ValueError(
                'A CommonName with the id {0} already exists as: \'{1}\''
                .format(cn.id, cn.name)
            )

        cn = cls()
        for key in dict_.keys():
            if key == 'index_id':
                cn.index = Index.query.get(dict_[key])
            elif key != 'grows_with':
                cn.__setattr__(key, dict_[key])
        return cn

    def gw_from_dict_(self, dict_):
        """Set grows_with based on information in `dict_`.

        Warning:
            This function should only be run after all CommonName instances
            have been loaded into the database!
        """
        for gwcn_id in dict_['gw_common_names']:
            gw = CommonName.query.get(gwcn_id)
            if not gw:
                raise RuntimeError('No CommonName exists with the id: {0}'
                                   .format(gwcn_id))
            self.gw_common_names.append(gw)
        for gwcv_id in dict_['gw_cultivars']:
            gw = Cultivar.query.get(gwcv_id)
            if not gw:
                raise RuntimeError('No Cultivar exists with the id: {0}'
                                   .format(gwcv_id))
            self.gw_cultivars.append(gw)

    @classmethod
    def from_ids(cls, ids):
        """Return a list of `CommonName` instances with `ids`.

        Args:
            ids: A collection of `CommonName.id` values to query for.
        
        Returns:
            list: A list of `CommonName` instances each with an id in `ids`.
        """
        return [cls.query.get(id) for id in ids]

    @classmethod
    def from_queryable_values(cls, name, index):
        """Return a `CommonName` instance filtered by `name` and `index`.

        Args:
            name: The name of the `CommonName` instance to query for.
            index: The name of the `Index` the `CommonName` instance being
                queried for belongs to.

        Returns:
            CommonName: A discrete instance of `CommonName`.
        """
        return cls.query\
            .join(Index, Index.id == cls.index_id)\
            .filter(cls.name == name, Index.name == index)\
            .one_or_none()

    @classmethod
    def from_queryable_dict(cls, d):
        """Return a `CommonName` instance with information from a dict.

        Args:
            d: A dict containing the name and index name of a `CommonName`.

        Returns:
            CommonName: A discrete instance of `CommonName`.
        """
        return cls.from_queryable_values(name=d['Common Name'],
                                         index=d['Index'])

    @classmethod
    def get_or_create(cls, name, index, stream=sys.stdout):
        """Load a `CommonName` if it exists, create it if not.

        Note:
            The boolean attribute 'created' is attached to the `CommonName`
            instance so we know whether the returned `CommonName` was created
            or loaded.

        Args:
            name: Name of the `CommonName`. Corresponds to `CommonName.name`.
            index: Name of the `Index` the `CommonName` belongs to.
                Corresponds to `CommonName.index.name`.
            stream: Optional IO stream to write messages to.

        Returns:
            CommonName: The `CommonName` loaded or created.
        """
        cn = cls.from_queryable_values(name=name, index=index)
        if cn:
            print('The CommonName \'{0}\' has been loaded from the database.'
                  .format(cn.name), file=stream)
            cn.created = False
        else:
            cn = cls(name=name)
            print('The CommonName \'{0}\' does not yet exist in the database, '
                  'so it has been created.'.format(cn.name), file=stream)
            cn.index = Index.get_or_create(name=index, stream=stream)
            cn.created = True
        return cn

    @property
    def arranged_name(self):
        """str: `self.name` as-is or rearranged if a comma is in it.

        Example:
            Bean, Pole = Pole Bean
        """
        if self.name:
            parts = self.name.split(', ')
            if len(parts) == 2:
                parts.append(parts.pop(0))
                return ' '.join(parts)
            else:
                return self.name
        else:
            return None

    @property
    def header(self):
        """str: `name` formatted for headers and titles."""
        if self.name:
            return '{0} Seeds'.format(self.arranged_name)
        else:
            return ''

    @property
    def select_field_title(self):
        """str: The title to use for a given `CommonName` in select fields."""
        if self.index and self.index.name:
            return '{0} ({1})'.format(self.name, self.index.name)
        else:
            return self.name

    @property
    def queryable_dict(self):
        """dict: The values needed to query a discrete `Cultivar` instance."""
        return {
            'Common Name': self.name,
            'Index': self.index.name if self.index else None
        }

    @property
    def html_botanical_names(self):
        """str: A list of botanical names formatted in HTML."""
        if not self.botanical_names:
            return ''
        else:
            names = []
            genuses = []
            for bn in self.botanical_names:
                parts = bn.fullname.split(' ', 1)
                if parts[0] in genuses:
                    name = ('<abbr title="{0}">{1}.</abbr> {2}'
                            .format(parts[0], parts[0][0], parts[1]))
                    names.append(name)
                else:
                    genuses.append(parts[0])
                    names.append(bn.fullname)
            return ', '.join(names)

    @property
    def has_public_cultivars(self):
        """bool: Whether or not `CommonName` has any public cultivars."""
        return self.cultivars and any(cv.public for cv in self.cultivars)

    def generate_slug(self):
        """Generate the string to use in URLs for this `CommonName`."""
        return slugify(self.arranged_name) if self.name else None


@event.listens_for(CommonName, 'before_insert')
@event.listens_for(CommonName, 'before_update')
def before_common_name_insert_or_update(mapper, connection, target):
    """Run tasks best done before flushing a `CommonName` to the database."""
    target.slug = target.generate_slug()


class BotanicalName(SynonymsMixin, db.Model):
    """Table for botanical (scientific) names of seeds.

    The botanical name is the scientific name of the species a seed belongs
    to. A correctly-formatted botanical name begins with a genus and species
    in binomial name format, or at least a genus followed by a descriptive
    comment.

    Attributes:
        name: The botanical name given istance of `BotanicalName` represents.
        common_names: `CommonName` instances a `BotanicalName` belongs to.
        sections: `Section` instances a `BotanicalName` belongs to.
        cultivars: `Cultivar` instances a `BotanicalName` belongs to.
        synonyms: `Synonym` instances representing synonyms of `BotanicalName`.
    """
    __tablename__ = 'botanical_names'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    common_names = db.relationship(
        'CommonName',
        secondary=botanical_names_to_common_names,
        back_populates='botanical_names'
    )
    sections = db.relationship(
        'Section',
        secondary=botanical_names_to_sections,
        back_populates='botanical_names'
    )
    cultivars = db.relationship('Cultivar', back_populates='botanical_name')
    synonyms = db.relationship('Synonym', back_populates='botanical_name')

    def __init__(self, name=None, common_names=None, synonyms=None):
        """Construct an instance of BotanicalName.

        Note:
            synonyms should be a string, not a collection of `Synonym` objects,
            as the only relevant data `Synonym` objects contain is the synonyms
            themselves.
        """
        self.name = name
        if common_names:  # Can't set collection to None
            self.common_names = common_names
        self.synonyms_string = synonyms

    def __repr__(self):
        """Return representation of BotanicalName in human-readable format.

        Returns:
            str: Representation formatted <BotanicalName '<.name>'> for
                 example: <BotanicalName 'Asclepias incarnata'>
        """
        return '<{0} \'{1}\'>'.format(self.__class__.__name__,
                                      self.name)

    @property
    def dict_(self):
        """A dictionary of values needed to make a copy of this in a new db."""
        return dict(
            id=self.id,
            name=self.name,
            common_names=[c.id for c in self.common_names]
        )

    @classmethod
    def from_dict_(cls, dict_):
        """Create a BotanicalName with data from dict_.

        Args:
            dict_: A dict generated by `BotanicalName.dict_`.

        Returns:
            BotanicalName: The `BotanicalName` generated from `dict_`.
        """
        bn = cls.query.get(dict_['id'])
        if bn:
            raise RuntimeError(
                'A BotanicalName with id {0} already exists as: \'{0}\''
                .format(bn.id, bn.name)
            )
        bn = cls()
        for key in dict_.keys():
            if key == 'common names':
                for cn_id in dict_[key]:
                    cn = CommonName.query.get(cn_id)
                    bn.common_names.append(cn)
            else:
                bn.__setattr__(key, dict_[key])

    @classmethod
    def get_or_create(cls, name, stream=sys.stdout, fix_bad=False):
        """Load a `BotanicalName` from db, or create it if it doesn't exist.

        Args:
            name: Name of the `BotanicalName`.
            stream: The buffer to print messages to.
            fix_bad: Whether or not to 'fix' invalid botanical names. Defaults
                to `False`.

        Returns:
            BotanicalName: The loaded or created `BotanicalName`.

        Raises:
            ValueError: If `name` is not valid, and `fix_bad` is not true.
        """
        if not cls.validate(name):
            if fix_bad:
                parts = name.split(' ')
                name = ' '.join([parts[0].title()] + parts[1:])
            else:
                raise ValueError('\'{0}\' is not a valid botanical name!'
                                 .format(name))
        bn = cls.query.filter(cls.name == name).one_or_none()
        if bn:
            bn.created = False
            print('The BotanicalName \'{0}\' has been loaded from the '
                  'database.'.format(bn.name))
        else:
            bn = BotanicalName(name=name)
            bn.created = True
            print('The BotanicalName \'{0}\' does not yet exist in the '
                  'database, so it has been created.'
                  .format(bn.name))
        return bn

    @property
    def genus(self):
        """str: The genus of the botanical name."""
        return self.name.split(' ')[0]

    @property
    def fullname(self):
        """str: Name with synonyms."""
        if self.synonyms:
            abbr = ('<abbr title="{0}">{1}.</abbr>'.format(self.genus,
                                                           self.genus[0]))
            syns = [s.name.replace(self.genus, abbr) for s in self.synonyms]
            return self.name + ' syn. ' + ', syn. '.join(syns)
        else:
            return self.name

    @staticmethod
    def validate(botanical_name):
        """Return True if botanical_name looks like a valid botanical name.

        Since there is a lot of variation in what constitutes a valid botanical
        name, the best we can reasonably do is make sure it contains at least
        two words, and the first could be a validly formatted genus.

        Examples:
            >>> BotanicalName.validate('Asclepias incarnata')
            True

            >>> BotanicalName.validate('asclepias incarnata')
            False

            >>> BotanicalName.validate('ASCLEPIAS INCARNATA')
            False

            >>> BotanicalName.validate('Asclepias Incarnata')
            True

            >>> BotanicalName.validate('Digitalis interspecies hybrid')
            True

        Args:
            botanical_name: A string containing a botanical name to
                check for valid formatting.

        Returns:
            bool: True if botanical_name looks valid, False if it doesn't look
                valid, or if attempting to parse it raises an exception.
        """
        try:
            nomens = botanical_name.strip().split(' ')
            if len(nomens) > 1 and nomens[0] == nomens[0].capitalize():
                return True
            else:
                return False
        except:
            return False


@event.listens_for(BotanicalName, 'before_insert')
@event.listens_for(BotanicalName, 'before_update')
def before_botanical_name_insert_or_update(mapper, connection, target):
    """Run tasks best run before adding a `BotanicalName` to the database."""
    # Validating `BotanicalName.name` should always be handled at the highest
    # level possible. Generally, this is either when a user inputs a name, or
    # a name is loaded from a file. This check exists so that failures to
    # validate `BotanicalName.name` before attempting to add it to the database
    # are caught.
    #
    # This exception should **never** be raised in production code!
    if target.name and not BotanicalName.validate(target.name):
        raise ValueError('An attempt to insert an invalid BotanicalName into '
                         'the database has occurred! Please ensure the name '
                         'of any new or edited BotanicalName is validated '
                         'before attempting to flush it to the database. You '
                         'can use BotanicalName.validate(name) to check '
                         'whether or not a name is valid.')


class Section(OrderingListMixin, db.Model):
    """Table for sections cultivars may fall under.

    Sections are subdivisions of a common name which contain cultivars, such
    as the series a cultivar belongs to (e.g. the 'Sparkler' series contains
    the cultivars 'Sparkler White Cleome' and 'Sparkler Lavender Cleome') or
    some characteristic that is useful to know, such as whether cultivars are
    dwarf varieties, or for cut flowers.


    Attributes:
        cn_pos: The position of the `Section' relative to its parent
            `CommonName` instance.
        parent_pos: The position of the `Section` relative to its parent
            `Section`.

        name: The name of the section.
        common_name: The `CommonName` the `Section` belongs to.

        botanical_names: Optional `BotanicalName` instances belonging to the
            `Section`.
        subtitle: Optional subtitle for `Section`.
        description: HTML description/intro for `Section`.
        parent: Optional parent `Section` the given `Section` is a subsection
            of.
        children: Optional child `Section` instances that are subsections of
            given `Section`.
        cultivars: `Cultivar` instances in given `Section`.
    """
    __tablename__ = 'sections'
    __table_args__ = (db.UniqueConstraint('name',
                                          'common_name_id',
                                          name='_section_name_cn_uc'),)
    id = db.Column(db.Integer, primary_key=True)

    # Positions
    cn_pos = db.Column(db.Integer)
    sec_pos = db.Column(db.Integer)

    # Data Required
    name = db.Column(db.String(64))
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship(
        'CommonName',
        foreign_keys=[common_name_id],
        back_populates='sections'
    )

    # Data Optional
    parent_common_name_id = db.Column(
        db.Integer, db.ForeignKey('common_names.id')
    )
    parent_common_name = db.relationship(
        'CommonName',
        foreign_keys=[parent_common_name_id],
        back_populates='child_sections'
    )
    botanical_names = db.relationship(
        'BotanicalName',
        secondary=botanical_names_to_sections,
        back_populates='sections'
    )
    subtitle = db.Column(db.String(64))
    description = db.Column(db.Text)
    parent_id = db.Column(db.Integer, db.ForeignKey('sections.id'))
    parent = db.relationship(
        'Section', remote_side=[id], back_populates='children'
    )
    children = db.relationship(
        'Section',
        order_by='Section.sec_pos',
        collection_class=ordering_list('sec_pos', count_from=1),
        back_populates='parent'
    )
    cultivars = db.relationship(
        'Cultivar',
        secondary=cultivars_to_sections,
        back_populates='sections'
    )
    child_cultivars = db.relationship(
        'Cultivar',
        foreign_keys='Cultivar.parent_section_id',
        order_by='Cultivar.sec_pos',
        collection_class=ordering_list('sec_pos', count_from=1),
        back_populates='parent_section'
    )

    def __init__(self,
                 name=None,
                 common_name=None,
                 description=None,
                 position=None):
        """Create an instance of a Section."""
        self.name = name
        self.common_name = common_name
        self.description = description
        if position is not None:
            self.position = position

    def __repr__(self):
        """Return a string representing a `Section` instance."""
        return '<{0} \'{1}\'>'.format(self.__class__.__name__, self.fullname)

    @property
    def slug(self):
        return slugify(self.name)

    @property
    def url(self):
        return url_for(
            'seeds.common_name',
            cn_slug=self.common_name.slug,
            idx_slug=self.common_name.index.slug,
            _anchor=self.slug,
            _external=True
        )

    @property
    def parent_collection(self):
        if self.parent:
            return self.parent.children
        elif self.common_name:
            return self.common_name.child_sections
        else:
            return None

    @classmethod
    def get_or_create(cls, name, common_name, index, stream=sys.stdout):
        """Load a `Section` from the db, or create it if it doesn't exist.

        Args:
            name: The name of the `Section`.
            common_name: The name of the `CommonName` it belongs to.
            index: The name of the `Index` it belongs to.
            stream: Buffer to output messages to.

        Returns:
            Section: The loaded or created `Section`.
        """
        sec = cls.query\
            .join(CommonName, CommonName.id == Section.common_name_id)\
            .join(Index, Index.id == CommonName.index_id)\
            .filter(Section.name == name,
                    CommonName.name == common_name,
                    Index.name == index)\
            .one_or_none()
        if sec:
            sec.created = False
            print('The Section \'{0}\' has been loaded from the database.'
                  .format(sec.fullname), file=stream)
        else:
            cn = CommonName.get_or_create(common_name, index, stream=stream)
            sec = Section(name=name, common_name=cn)
            sec.created = True
            print('The Section \'{0}\' does not yet exist in the database, '
                  'so it has been created'.format(sec.fullname), file=stream)
        return sec

    @property
    def fullname(self):
        """str: Name of `Section` with name of `CommonName`."""
        fn = []
        if self.name:
            fn.append(self.name)
        if self.common_name:
            fn.append(self.common_name.name)
        if fn:
            return ' '.join(fn)
        else:
            return None

    @property
    def has_public_cultivars(self):
        """bool: Whether or not `Section` has any public cultivars."""
        rv = False
        if self.cultivars:
            if any(cv.public for cv in self.cultivars):
                rv = True
            if all(cv.featured for cv in self.cultivars):
                rv = False
        elif self.children:
            if any(child.has_public_cultivars for child in self.children):
                rv = True
        return rv

    def set_common_name(self, cn, insert_at=None):
        """Set common_name and deal with positioning.
        
        Args:
            cn: The CommonName to set.
        """
        if cn is not None:
            if insert_at is None or insert_at > len(cn.child_sections):
                insert_at = len(cn.child_sections)
            self.common_name = cn
            self.parent = None
            if self not in cn.child_sections:
                cn.child_sections.insert(insert_at, self)
            else:
                csecs = cn.child_sections
                csecs.insert(insert_at, csecs.pop(csecs.index(self)))
        else:
            self.common_name = None
            self.parent_common_name = None

    def set_parent(self, other, insert_at=None):
        """Set other as parent, and deal with positioning."""
        if other is not self:
            if other is not None:
                self.parent_common_name = None
                if insert_at is None or insert_at > len(other.children):
                    insert_at = len(other.children)
                if self not in other.children:
                    other.children.insert(insert_at, self)
                else:
                    oc = other.children
                    oc.insert(insert_at, oc.pop(oc.index(self)))
            else:
                self.parent = None
                self.parent_common_name = self.common_name
        else:
            raise ValueError('Cannot set section as its own parent!')


@event.listens_for(Section.parent, 'set')
def section_parent_no_loop(target, value, oldvalue, initiator):
    """Do not allow a parent-child loop to be created.

    If a `Section` parent-child loop is created, it will cause endless loops
    when iterating through parent-child relationships.
    """
    parents = [target]
    p = value
    while p is not None:
        if value in parents:
            raise RuntimeError(
                'Setting {0} as parent to {1} would create a parent-child '
                'loop!'.format(value, target)
            )
        else:
            parents.append(p)
            p = p.parent


@event.listens_for(CommonName.sections, 'append')
def common_name_sections_appended(target, value, initiator):
    if not value.parent:
        value.parent_common_name = target


@event.listens_for(CommonName.sections, 'remove')
def common_name_sections_removed(target, value, initiator):
    value.parent_common_name = None


@event.listens_for(Section.children, 'append')
def section_children_appended(target, value, intiator):
    value.parent_common_name = None


@event.listens_for(Section.children, 'remove')
def section_children_removed(target, value, initiator):
    value.parent_common_name = value.common_name


class Cultivar(OrderingListMixin, SynonymsMixin, db.Model):
    """Table for cultivar data.

    A cultivar is an individual variety of plant, and represents the most
    specific category seeds fall under. This is the primary attribute that
    products (packets) are attached to.

    Note:
        A cultivar must have a unique combination of name and common name,
        otherwise it could result in multiple results from a query intended to
        fetch only one cultivar.

    Attributes:
        cn_pos: Position relative to parent `CommonName`.
        sec_pos: Position relative to parent `Section`.

        name: The name of the cultivar, without common name. e.g. 'Sparkler
            White' for Sparkler White Cleome.
        slug: A URL-friendly version of `name`. The slug for a `Cultivar` is
            not necessarily unique, as it is always used in conjunction with
            a `CommonName` slug, so the unique constraint between `name` and
            `common_name_id` prevents clashes.
        common_name: The `CommonName` a `Cultivar` belongs to.

        subtitle: An optional subtitle for cases in which the subtitle under
            a `Cultivar` on a page should be something other than
            '<`Cultivar.common_name.name`> Seeds', as in Fuseables, e.g.
            'Bacopa/Petunia Multi-Species Seeds'.
        section: Optional `Section` a `Cultivar` belongs to.
        botanical_name: The `BotanicalName` of given `Cultivar`.
        description: An optional HTML description of a cultivar.
        new_until: An optional date to mark a `Cultivar` as new until.
        featured: Whether or not `Cultivar` should be featured on its common
            name page.
        active: True if the cultivar's stock is being actively replenished,
            False if not.
        in_stock: True if a cultivar is in stock, False if not.
        visible: Whether or not this cultivar should be shown on automatically
            generated pages. Cultivars with `visible` set to `False` can still
            be shown on custom pages.
        thumbnail: An optional thumbnail `Image` for a `Cultivar`.
        images: `Image` instances which are not thumbnails, but which are
            associated with a `Cultivar`.
        vegetable_data: Optional additional information to be used if given
            `Cultivar` is a "vegetable". (Really, food plant in general.)
        packets: The seed `Packet` instances belonging to given `Cultivar`.
        synonyms: Synonyms for a `Cultivar`.
        custom_pages: `CustomPage` instances that include given `Cultivar`.
    """
    __tablename__ = 'cultivars'
    id = db.Column(db.Integer, primary_key=True)
    __table_args__ = (db.UniqueConstraint('name',
                                          'common_name_id',
                                          name='_cultivar_name_cn_uc'),)

    # Positions
    cn_pos = db.Column(db.Integer)
    sec_pos = db.Column(db.Integer)

    # Data Required
    name = db.Column(db.String(64))
    slug = db.Column(db.String(64))
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship(
        'CommonName',
        foreign_keys=common_name_id,
        back_populates='cultivars')

    # Data Optional
    subtitle = db.Column(db.String(64))
    section_id = db.Column(db.Integer, db.ForeignKey('sections.id'))
    sections = db.relationship(
        'Section',
        secondary=cultivars_to_sections,
        back_populates='cultivars'
    )
    botanical_name_id = db.Column(
        db.Integer,
        db.ForeignKey('botanical_names.id')
    )
    botanical_name = db.relationship(
        'BotanicalName',
        back_populates='cultivars'
    )
    description = db.Column(db.Text)
    new_until = db.Column(db.Date)
    featured = db.Column(db.Boolean, default=False)
    active = db.Column(db.Boolean)
    in_stock = db.Column(db.Boolean)
    visible = db.Column(db.Boolean)
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship(
        'Image',
        foreign_keys=thumbnail_id,
        back_populates='cultivars_with_thumb'
    )
    images = db.relationship(
        'Image',
        secondary=cultivars_to_images,
        back_populates='cultivars'
    )
    vegetable_data_id = db.Column(
        db.Integer,
        db.ForeignKey('vegetable_data.id')
    )
    vegetable_data = db.relationship(
        'VegetableData',
        back_populates='cultivar'
    )
    packets = db.relationship(
        'Packet',
        cascade='all, delete-orphan',
        back_populates='cultivar'
    )
    synonyms = db.relationship('Synonym', back_populates='cultivar')
    gw_common_names = db.relationship(
        'CommonName',
        secondary=cultivars_to_gw_common_names
    )
    gw_cultivars = db.relationship(
        'Cultivar',
        secondary=cultivars_to_gw_cultivars,
        primaryjoin=id == cultivars_to_gw_cultivars.c.parent_id,
        secondaryjoin=id == cultivars_to_gw_cultivars.c.child_id
    )
    custom_pages = db.relationship(
        'CustomPage',
        secondary=cultivars_to_custom_pages,
        back_populates='cultivars'
    )
    parent_common_name_id = db.Column(
        db.Integer,
        db.ForeignKey('common_names.id')
    )
    parent_common_name = db.relationship(
        'CommonName',
        foreign_keys=parent_common_name_id,
        back_populates='child_cultivars'
    )
    parent_section_id = db.Column(db.Integer, db.ForeignKey('sections.id'))
    parent_section = db.relationship(
        'Section',
        foreign_keys=parent_section_id,
        back_populates='child_cultivars'
    )

    def __init__(self,
                 name=None,
                 common_name=None,
                 section=None,
                 botanical_name=None,
                 description=None,
                 new_until=None,
                 active=None,
                 in_stock=None,
                 invisible=None):
        """Create an instance of Cultivar.

        Note:
            `images` and `thumbnail` have been left out because in practice
            they should have some work done to ensure they are set correctly.
        """
        self.name = name
        self.common_name = common_name
        self.section = section
        self.botanical_name = botanical_name
        self.description = description
        self.new_until = new_until
        if active is not None:
            self.active = active
        if in_stock is not None:
            self.in_stock = in_stock
        if invisible is not None:
            self.invisible = invisible

    def __repr__(self):
        """Return representation of Cultivar in human-readable format."""
        return '<{0} \'{1}\'>'.format(self.__class__.__name__,
                                      self.fullname)

    @property
    def url(self):
        # TODO: Integrate option for if cultivar pages are active.
        return url_for(
            'seeds.common_name',
            cn_slug=self.common_name.slug,
            idx_slug=self.common_name.index.slug,
            _anchor=self.slug,
            _external=True
        )

    @property
    def link_html(self):
        return '<a href="{0}">{1}</a>'.format(self.url, self.fullname)

    @property
    def parent_collection(self):
        if self.parent_section:
            return self.parent_section.child_cultivars
        elif self.common_name:
            return self.common_name.child_cultivars
        else:
            return None

    @property
    def gw_common_names_ids(self):
        """Return list of ids of `gw_common_names`."""
        return [gwcn.id for gwcn in self.gw_common_names]

    @property
    def gw_cultivars_ids(self):
        """Return list of ids of `gw_cultivars`."""
        return [gwcv.id for gwcv in self.gw_cultivars]

    @property
    def gw_links(self):
        gws = self.gw_common_names + self.gw_cultivars
        return list_to_english((gw.link_html for gw in gws))

    @classmethod
    def from_ids(cls, ids):
        """Get `Cultivar` instances corresponding to `ids`.

        Args:
            ids: A collection of `Cultivar.id` to query.

        Returns:
            list: A list of `Cultivar` instances with given ids.
        """
        return [cls.query.get(id) for id in ids]

    @classmethod
    def from_queryable_values(cls, name, common_name, index):
        """Query a `Cultivar` from the database given its core values.

        The core values of a `Cultivar` are its name, its common name, the
        index it belongs to.

        Args:
            name: The name of the cultivar.
            common_name: The common name of the cultivar.
            index: The index the cultivar's common name (and thus the cultivar
                itself) falls under.

        Returns:
            Cultivar: A discrete instance of `Cultivar`.
            None: If no cultivar exists with the given parameters.
        """
        return cls.query\
            .join(CommonName, CommonName.id == cls.common_name_id)\
            .join(Index, Index.id == CommonName.index_id)\
            .filter(cls.name == name,
                    CommonName.name == common_name,
                    Index.name == index)\
            .one_or_none()

    @classmethod
    def from_queryable_dict(cls, d):
        """Query a `Cultivar` from db given its core values in a dict.

        Args:
            d: A dictionary containing the necessary values to query a discrete
                `Cultivar` from the database.

        Returns:
            Cultivar: A discrete instance of `Cultivar`.
            None: If no `Cultivar` exists with the given parameters.
        """
        return cls.from_queryable_values(name=d['Cultivar Name'],
                                         common_name=d['Common Name'],
                                         index=d['Index'])

    @classmethod
    def get_or_create(cls,
                      name,
                      common_name,
                      index,
                      stream=sys.stdout):
        """Load a cultivar if it exists, create it if not.

        Notes:
            The boolean attribute 'created' is attached to the `CommonName`
            instance so we know whether the returned `CommonName` was created
            or loaded.

        Args:
            name: Name of the `Cultivar`.
            common_name: Name of the `CommonName` this `Cultivar` belongs to.
            index: `Index` the `CommonName` belongs to.
            stream: Optional IO stream to write messages to.
        """
        cv = cls.from_queryable_values(name=name,
                                       common_name=common_name,
                                       index=index)
        if cv:
            cv.created = False
            print('The Cultivar \'{0}\' has been loaded from the database.'
                  .format(cv.fullname), file=stream)
        else:
            cv = cls(name=name)
            cv.created = True
            cv.common_name = CommonName.get_or_create(name=common_name,
                                                      index=index,
                                                      stream=stream)
            print('The Cultivar \'{0}\' does not yet exist in the database, '
                  'so it has been created.'.format(cv.fullname), file=stream)
        return cv

    @property
    def fullname(self):
        """str: Full name of cultivar including common name."""
        fn = [self.name]
        if self.common_name and self.common_name.name != self.name:
            fn.append(self.common_name.name)
        if fn:
            return ' '.join(fn)
        else:
            return None

    @property
    def queryable_dict(self):
        """dict: A dict with name, common_name, and index of `self`.

        Note:
            Any or all values can be `None`, as passing <obj.attribute> == None
            to db.Model.query.filter() will return `None` if no objects in the
            database have the attribute in question set to `None`. A `dict`
            with all values set to `None` won't raise an exception when used
            for a query, it will just yield no results.
        """
        name = self.name
        common_name = self.common_name.name if self.common_name else None
        index = (self.common_name.index.name if self.common_name
                 and self.common_name.index else None)
        return {
            'Cultivar Name': name,
            'Common Name': common_name,
            'Index': index
        }

    @property
    def public(self):
        """bool: Whether or not `Cultivar` is visible to non-admin users."""
        return self.active and self.visible

    @property
    def new_for(self):
        """int: Year cultivar is new for, if applicable."""
        if self.new_until and self.new_until > datetime.date.today():
            return self.new_until.year
        else:
            return None

    def generate_slug(self):
        """Generate a string for use in URLs for pages that use `Cultivar`."""
        return slugify(self.name) if self.name else None


@event.listens_for(Cultivar, 'before_insert')
@event.listens_for(Cultivar, 'before_update')
def before_cultivar_insert_or_update(mapper, connection, target):
    """Update a `Cultivar` before flushing changes to the database."""
    target.slug = target.generate_slug()


@event.listens_for(CommonName.cultivars, 'append')
def common_name_cultivars_appended(target, value, initiator):
    if not value.parent_section:
        target.child_cultivars.insert(len(target.child_cultivars), value)


@event.listens_for(CommonName.cultivars, 'remove')
def common_name_cultivars_removed(target, value, initiator):
    value.parent_common_name = None


@event.listens_for(Section.child_cultivars, 'append')
def section_child_cultivars_appended(target, value, intiator):
    value.parent_common_name = None


@event.listens_for(Section.child_cultivars, 'remove')
def section_child_cultivars_removed(target, value, initiator):
    if not value.sections:
        value.parent_common_name = value.common_name

@event.listens_for(Section.cultivars, 'append')
def section_cultivars_appended(target, value, initiator):
    if target.parent and value not in target.parent.cultivars:
        target.parent.cultivars.append(value)
    if not target.children or set(target.children).isdisjoint(value.sections):
        target.child_cultivars.insert(len(target.child_cultivars), value)

@event.listens_for(Section.cultivars, 'remove')
def section_cultivars_removed(target, value, initiator):
    print('removing parent {0} from {1}'.format(value, target))
    try:
        for c in target.children:
            try:
                c.cultivars.remove(value)
            except ValueError:
                pass
    except TypeError:
        pass
    if target.parent:
        value.parent_section = target.parent
        print(value.parent_section)
    else:
        value.parent_section = None
        value.parent_common_name = value.common_name


class Packet(db.Model):
    """Table for seed packet information.

    Packet information includes data for each individual type of packet we
    sell, such as the size and price of a given packet. Each seed can have
    multiple different associated packets, due to different sizes (such as
    jumbo) and prices associated with different packet sizes.

    Attributes:
        sku: Product SKU for the packet.
        price: Price (in US dollars) for this packet.
        quantity: The `Quantity` of seeds in a `Packet`, including units of
            measurement.
        cultivar: The `Cultivar` a `Packet` belongs to.
    """
    __tablename__ = 'packets'
    id = db.Column(db.Integer, primary_key=True)
    sku = db.Column(db.String(32), unique=True)
    price = db.Column(USDollar)
    quantity_id = db.Column(db.Integer, db.ForeignKey('quantities.id'))
    quantity = db.relationship('Quantity', back_populates='packets')
    cultivar_id = db.Column(db.Integer, db.ForeignKey('cultivars.id'))
    cultivar = db.relationship('Cultivar', back_populates='packets')

    def __repr__(self):
        return '<{0} SKU #{1}>'.format(self.__class__.__name__, self.sku)

    def __init__(self, sku=None, price=None, quantity=None, cultivar=None):
        """Create an instance of Packet.
        """
        self.sku = sku
        self.price = price
        if quantity:
            self.quantity = quantity
        if cultivar:
            self.cultivar = cultivar

    @classmethod
    def from_values(cls, sku, price, quantity, units):
        """Create a `Packet` given a series of values.

        Args:
            sku: Product SKU #.
            price: Price of packet.
            quantity: Amount of seeds in packet.
            units: Units of measurement for quantity of seeds in packet.

        Returns:
            Packet: A new `Packet` instance.

        Raises:
            ValueError: If given `sku` already exists.
        """
        if row_exists(cls.sku, sku):
            raise ValueError('A packet already exists with the SKU \'{0}\'!'
                             .format(sku))
        qty = Quantity.query\
            .filter(Quantity.value == quantity, Quantity.units == units)\
            .one_or_none()
        if not qty:
            qty = Quantity(value=quantity, units=units)
        return cls(sku=sku, price=price, quantity=qty)

    @property
    def info(self):
        """str: A formatted string containing the data of this packet."""
        if self.quantity:
            qv = self.quantity.value
            qu = self.quantity.units
        else:
            qv = None
            qu = None
        return 'SKU #{0}: ${1} for {2} {3}'.format(self.sku,
                                                   self.price,
                                                   qv,
                                                   qu)


class Quantity(db.Model):
    """Table for quantities.

    A Quantity consists of a numerical value and a unit of measurement. Since
    some numerical values may be integers, some may be fractions, and some may
    be decimal numbers, all numerical values are stored in internal use
    attributes `_numerator`, `_denominator`, and `_float`. Integers and
    fractions are returned using `_numerator` and `_denominator` (since a
    fraction with a denominator of 1 is an integer) while decimal numbers are
    specified by setting `is_decimal` to True, and utilize `_float` to return
    the value.

    Attributes:
        is_decimal: Whether or not the stored quantity represents a
            decimal number, as opposed to fraction or integer.
        units: Unit of measurement of a quantity. (seeds, grams, etc.)
        packets: `Packet` instances which share a `Quantity`.
    """
    __tablename__ = 'quantities'
    id = db.Column(db.Integer, primary_key=True)
    __table_args__ = (db.UniqueConstraint('_float',
                                          'units',
                                          'is_decimal',
                                          name='_float_units_uc'),)
    _numerator = db.Column(db.Integer)
    _denominator = db.Column(db.Integer)
    _float = db.Column(db.Float)
    is_decimal = db.Column(db.Boolean, default=False)
    units = db.Column(db.String(32))
    packets = db.relationship('Packet', back_populates='quantity')

    def __init__(self, value=None, units=None):
        if value:
            self.value = value
        if units:
            self.units = units

    def __repr__(self):
        return '<{0} \'{1} {2}\'>'.format(self.__class__.__name__,
                                          self.value,
                                          self.units)

    @property
    def html_value(self):
        """str: A string of `self.value` w/ fractions in HTML if applicable."""
        if isinstance(self.value, Fraction):
            if self.value == Fraction(1, 4):
                return '&frac14;'
            elif self.value == Fraction(1, 2):
                return '&frac12;'
            elif self.value == Fraction(3, 4):
                return '&frac34;'
            elif self.value == Fraction(1, 3):
                return '&#8531;'
            elif self.value == Fraction(2, 3):
                return '&#8532;'
            elif self.value == Fraction(1, 5):
                return '&#8533;'
            elif self.value == Fraction(2, 5):
                return '&#8534;'
            elif self.value == Fraction(3, 5):
                return '&#8535;'
            elif self.value == Fraction(4, 5):
                return '&#8536;'
            elif self.value == Fraction(1, 6):
                return '&#8537;'
            elif self.value == Fraction(5, 6):
                return '&#8538;'
            elif self.value == Fraction(1, 8):
                return '&#8539;'
            elif self.value == Fraction(3, 8):
                return '&#8540;'
            elif self.value == Fraction(5, 8):
                return '&#8541;'
            elif self.value == Fraction(7, 8):
                return '&#8542;'
            else:
                return '<span class="fraction"><sup>{0}</sup>&frasl;'\
                    '<sub>{1}</sub></span>'.format(self._numerator,
                                                   self._denominator)
        return str(self.value)

    @staticmethod
    def dec_check(val):
        """Check if a given value is a decimal number.

        Args:
            val: A value to check the (perfectly cromulent) decimalness of.

        Returns:
            True: If value appears to be a decimal number.
            False: If value can't be determined to be a decimal number.

        Examples:
            >>> Quantity.dec_check(3.14)
            True

            >>> Quantity.dec_check(42)
            False

            >>> Quantity.dec_check('3.50')
            True

            >>> Quantity.dec_check('tree fiddy')
            False

            >>> Quantity.dec_check('8675309')
            False

            >>> Quantity.dec_check(Decimal('1.99'))
            True

            >>> Quantity.dec_check(Fraction(3, 4))
            False

            >>> Quantity.dec_check('127.0.0.1')
            False
        """
        if isinstance(val, Decimal) or isinstance(val, float):
            return True
        if isinstance(val, Fraction):
            return False
        try:
            float(val)
            try:
                int(val)
                return False
            except:
                return True
        except:
            return False

    @staticmethod
    def fraction_to_str(val):
        """Convert a Fraction to a string containing a mixed number.

        Args:
            val: A fraction to convert to a string fraction or
                mixed number.

        Returns:
            str: A string containing a fraction or mixed number.

        Raises:
            TypeError: If given a non-Fraction value.

        Examples:
            >>> Quantity.fraction_to_str(Fraction(1, 2))
            '1/2'

            >>> Quantity.fraction_to_str(Fraction(11, 4))
            '2 3/4'

            >>> Quantity.fraction_to_str(Fraction(123, 11))
            '11 2/11'
        """
        if isinstance(val, Fraction):
            if val.numerator > val.denominator:
                whole = val.numerator // val.denominator
                part = Fraction(val.numerator % val.denominator,
                                val.denominator)
                return '{0} {1}'.format(whole, part)
            else:
                return str(val)
        else:
            raise TypeError('val must be of type Fraction')

    @staticmethod
    def to_float(val):
        """Convert a value into a float as would be stored in `_float`.

        Args:
            val: Value to convert to a float.

        Returns:
            float: The converted value.
        """
        if Quantity.dec_check(val):
            return float(val)
        elif isinstance(val, str):
            frac = Quantity.str_to_fraction(val)
        else:
            frac = Fraction(val)
        return float(frac)

    @staticmethod
    def str_to_fraction(val):
        """Convert a string containing a number into a fraction.

        Args:
            val: A string containing a fraction or mixed number to convert
                to a `Fraction`.

        Returns:
            Fraction

        Raises:
            TypeError: If val is not a string.
            ValueError: If val could not be converted to Fraction.

        Examples:
            >>> Quantity.str_to_fraction('5')
            Fraction(5, 1)

            >>> Quantity.str_to_fraction('3/4')
            Fraction(3, 4)

            >>> Quantity.str_to_fraction('11 2/11')
            Fraction(123, 11)

            >>> Quantity.str_to_fraction('1.1')
            Fraction(11, 10)
        """
        val = val.strip()
        try:
            return Fraction(val)
        except:
            if ' ' in val:
                parts = val.split(' ')
                if len(parts) == 2 and '/' in parts[1]:
                    try:
                        whole = int(parts[0])
                        frac = Fraction(parts[1])
                        return frac + whole
                    except:
                        pass
        raise ValueError('value {0} of type {1} could not be converted to '
                         'Fraction'.format(val, type(val)))

    @classmethod
    def from_queryable_values(cls, value, units):
        """Query a Quantity from the database given its value and units."""
        return cls.query\
            .filter(cls.value == value,
                    cls.units == units,
                    cls.is_decimal == cls.dec_check(value))\
            .one_or_none()

    @hybrid_property
    def value(self):
        """"int, float, Fraction: The value of a quantity in the same format
                it was entered.

            Setter:
                Convert value a Fraction, store its numerator and denominator,
                and store a floating point version to allow querying based on
                quantity value. Flag is_decimal if the initial value is a
                decimal (floating point) number.
        """
        if self._float is not None:
            if self.is_decimal:
                return self._float
            elif self._denominator == 1:
                return self._numerator
            else:
                return Fraction(self._numerator, self._denominator)
        else:
            return None

    class ValueComparator(Comparator):
        """Comparator for `Quantity.value`.

        This comparator allows using values in queries in human-readable form,
        as they would be entered when setting `value` for an instance of
        `Quantity`. This way users do not have to convert values to float or
        worry about what kind of number the value is.
        """
        def operate(self, op, other):
            """Check a value in a query filter.

            Since `_float` and `is_decimal` are needed to retrieve the Quantity
            instance with the correct value, a filter using `value` needs check
            whether or not a `value` is a decimal number, and convert it to a
            float in order to compare it to `_float` and `is_decimal`. Luckily
            since `is_decimal` is just a boolean value, using == to check
            against it is perfectly fine regardless of what operator is being
            used to check `value`.
            """
            return and_(op(Quantity._float, Quantity.to_float(other)),
                        Quantity.is_decimal == Quantity.dec_check(other))

    @value.comparator
    def value(cls):
        return Quantity.ValueComparator(cls)

    @value.setter
    def value(self, val):
        if val is not None:
            if Quantity.dec_check(val):
                self.is_decimal = True
                self._float = float(val)
                self._numerator = None
                self._denominator = None
            else:
                self.is_decimal = False
                if isinstance(val, str):
                    frac = Quantity.str_to_fraction(val)
                else:
                    frac = Fraction(val)
                self._numerator = frac.numerator
                self._denominator = frac.denominator
                self._float = float(frac)
        else:
            self.is_decimal = None
            self._numerator = None
            self._denominator = None
            self._float = None

    @property
    def str_value(self):
        if isinstance(self.value, Fraction):
            return self.fraction_to_str(self.value)
        else:
            return str(self.value)


@event.listens_for(Packet.quantity, 'set')
def delete_orphaned_quantity(target, value, oldvalue, initiatior):
    """Delete quantities that no longer have packets associated with them."""
    if hasattr(oldvalue, 'packets') and len(oldvalue.packets) <= 1:
        if target in oldvalue.packets or not oldvalue.packets:
            db.session.delete(oldvalue)


class Synonym(db.Model):
    """Table for synonyms of other objects.

    Attributes:
        name: The synonym itself.
        common_name: A `CommonName` a `Synonym` belongs to.
        botanical_name: A `BotanicalName` a `Synonym` belongs to.
        cultivar: A `Cultivar` a `Synonym` belongs to.
    """
    __tablename__ = 'synonyms'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64))
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship('CommonName', back_populates='synonyms')
    botanical_name_id = db.Column(
        db.Integer,
        db.ForeignKey('botanical_names.id')
    )
    botanical_name = db.relationship(
        'BotanicalName',
        back_populates='synonyms'
    )
    cultivar_id = db.Column(db.Integer, db.ForeignKey('cultivars.id'))
    cultivar = db.relationship('Cultivar', back_populates='synonyms')

    def __init__(self, name=None):
        self.name = name

    def __repr__(self):
        """Return string representing a synonym."""
        if self.parent:
            return('<{0} \'{1}\' of {2}: \'{3}\'>'
                   .format(self.__class__.__name__,
                           self.name,
                           None if not self.parent else
                           self.parent.__class__.__name__,
                           None if not self.parent else self.parent.name))
        else:
            return('<{0} \'{1}\'>'.format(self.__class__.__name__, self.name))

    @property
    def parent(self):
        """object: Return whatever object this synonym is linked to.

        Note:
            Validation of whether or not a synonym is only linked to one
            object is handled by this property as well, as it needs to check
            validity anyway to ensure it returns the correct value. Rather
            than using a separate validation method, the best way to validate
            a `Synonym` is just to try to access `Synonym.parent`.
        """
        parents = []
        if self.common_name:
            parents.append(self.common_name)
        if self.botanical_name:
            parents.append(self.botanical_name)
        if self.cultivar:
            parents.append(self.cultivar)
        if len(parents) == 0:
            return None
        if len(parents) == 1:
            return parents.pop()
        else:
            raise ValueError(
                'Each synonym should only be linked to one other table, but '
                'this one is linked to: {0}'
                .format(', '.join([obj.__repr__() for obj in parents]))
            )


@event.listens_for(Synonym, 'before_insert')
@event.listens_for(Synonym, 'before_update')
def before_synonym_insert_or_update(mapper, connection, target):
    """Run tasks needed before flushing a `Synonym` to the database."""
    # Since Synonym has multiple possible relationships, but each synonym
    # should only correspond to one object, we need to ensure a Synonym only
    # has one relationship set before flushing it to the database.
    #
    # Simply running the Synonym.parent property will raise an appropriate
    # exception if more than one relationship is set.
    target.parent


class CustomPage(db.Model):
    """Table for custom pages that cover edge cases.

    Since there will always be some edge cases in which we may want to create
    pages that can't easily be automatically generated (for example, a page
    that lists cultivars from multiple common names) this table allows for
    generic pages to be made.

    Attributes:
        title: Page title to be used in <title> and for queries.
        content: The HTML content of the page, including parseable tokens.
        cultivars: `Cultivar` instances to be listed on a `CustomPage`.
    """
    __tablename__ = 'custom_pages'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(64), unique=True)
    content = db.Column(db.Text)
    cultivars = db.relationship(
        'Cultivar',
        secondary=cultivars_to_custom_pages,
        back_populates='custom_pages'
    )


class Image(db.Model):
    """Table for image information.

    Any image uploaded to be used with the cultivar model should utilize this
    table for important image data like filename and location.

    Attributes:
        filename: File name of an image.
        width: Width of an image in pixels.
        height: Height of an image in pixels.

        index: The `Index` an `Image` is thumbnail for.
        common_name: The `CommonName` an `Image` is thumbnail for.
        cultivar: The `Cultivar` an `Image` is thumbnail for.
        cultivars: `Cultivar` instances an image is not thumbnail for, but
            still associated with.

    """
    __tablename__ = 'images'
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(32), unique=True)
    width = db.Column(db.Integer)
    height = db.Column(db.Integer)

    # relationships
    indexes_with_thumb = db.relationship(
        'Index',
        back_populates='thumbnail')
    common_names_with_thumb = db.relationship(
        'CommonName',
        back_populates='thumbnail'
    )
    cultivars_with_thumb = db.relationship(
        'Cultivar',
        back_populates='thumbnail'
    )
    cultivars = db.relationship(
        'Cultivar',
        secondary=cultivars_to_images,
        back_populates='images'
    )

    def __init__(self, filename=None, make_unique=False):
        if filename:
            self.filename = filename
        if make_unique:
            self.make_unique()

    def __repr__(self):
        return '<{0} filename: \'{1}\'>'.format(self.__class__.__name__,
                                                self.filename)

    @property
    def url(self):
        return url_for('static', filename=self.path, _external=True)

    @property
    def dict_(self):
        """Return dict with needed info to copy `Image`."""
        return {
            'id': self.id,
            'filename': self.filename
        }

    @classmethod
    def from_form_field(cls, field, make_unique=True):
        """Create an Image from data from a wtforms FileField.

        Args:
            field: The FileField to get data from.
            make_unique: Whether or not to make sure the created image does
                not overwrite existing image data. Defaults to True for safety,
                but can be set False if, for example, one wants to replace an
                old version of the image with a new one when editing the object
                it belongs to.
        """
        img = cls(filename=field.data.filename,
                  make_unique=make_unique)
        field.data.save(img.full_path)
        img.set_dimensions()
        return img

    def save_form_field_image(self, field):
        """Save an image via a wtforms FileField."""
        field.data.save(self.full_path)
        self.set_dimensions()

    @property
    def url(self):
        return url_for('static', filename=self.path, _external=True)

    @property
    def path(self):
        """str: The path to the image file relative to the static folder."""
        return os.path.join('images', 'plants',  self.filename)

    @property
    def full_path(self):
        """str: The full path to the file this image entry represents."""
        return os.path.join(current_app.config.get('PLANT_IMAGES_FOLDER'),
                            self.filename)

    @property
    def is_extra_wide(self):
        """bool: True if the width of image is at least twice its height."""
        if self.width and self.height:
            return self.width >= 2 * self.height
        else:
            return None

    def delete_file(self):
        """Deletes the image file associated with this Image object."""
        os.remove(self.full_path)

    def exists(self):
        """Check whether or not file associated with this Image exists."""
        return os.path.exists(self.full_path)

    def add_postfix(self, postfix):
        """Rename an image to add a postfix to it.

        Usually this would be used for when an image with the same filename is
        added, thus allowing the new image to be renamed instead of overwriting
        the existing file.
        """
        parts = os.path.splitext(self.filename)
        self.filename = parts[0] + postfix + parts[1]

    def make_unique(self):
        """Rename an image if it would overwrite an existing image."""
        old_name = self.filename
        count = 0
        while self.exists():
            count += 1
            parts = os.path.splitext(old_name)
            self.filename = parts[0] + '_' + str(count) + parts[1]

    def rename(self, new_name):
        """Rename an image with new name.

        Args:
            new_name: The new filename to use.
        """
        old_path = self.full_path
        self.filename = new_name
        shutil.move(old_path, self.full_path)

    def set_dimensions(self):
        """Set width and height if the image exists."""
        if self.exists():
            img = Pimage.open(self.full_path)
            self.width = img.width
            self.height = img.height


class VegetableData(db.Model):
    """Table for vegetable-specific data.

    In addition to the usual information, vegetables often have an estimate
    for number of days it takes to reach the first harvest, and whether or not
    the plants are open pollinated.

    Attributes:
        open_pollinated: Whether or not the vegetable is open pollinated.
        hybrid: Whether or not a vegetable is hybrid.
        days_to_maturity: A string containing the number of days (or a range
            of the number of days) it is estimated to take for the plant to be
            ready to harvest.
        cultivar: The `Cultivar` that the given `VegetableData` belongs to.
    """
    __tablename__ = 'vegetable_data'
    id = db.Column(db.Integer, primary_key=True)
    open_pollinated = db.Column(db.Boolean)
    hybrid = db.Column(db.Boolean)
    # TODO: Make custom comparator for days_to_maturity.
    days_to_maturity = db.Column(db.String(64))
    cultivar = db.relationship(
        'Cultivar',
        uselist=False,
        back_populates='vegetable_data'
    )

    def __init__(self, open_pollinated=False, days_to_maturity=None):
        self.open_pollinated = open_pollinated
        self.days_to_maturity = days_to_maturity


@event.listens_for(SignallingSession, 'before_attach')
def auto_position_before_attach(session, instance):
    """Auto-generate positions for new instances of classes that have them."""
    if hasattr(instance, 'auto_position'):
        instance.auto_position()


@event.listens_for(Image, 'before_delete')
def delete_image_file_before_delete(mapper, connection, target):
    """Delete image file of `Image` instance before the instance is deleted."""
    try:
        target.delete_file()
    except FileNotFoundError:
        print(target.full_path)
        pass  # If the file doesn't exist, there's no need to delete it.


if __name__ == '__main__':  # pragma: no cover
    import doctest
    doctest.testmod()
