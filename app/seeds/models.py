# -*- coding: utf-8 -*-
# This file is part of SGS-Flask.

# SGS-Flask is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# SGS-Flask is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Copyright Swallowtail Garden Seeds, Inc


"""
app.seeds.models

This module contains SQLAlchemy declarative models for product (seeds)
information, along with functions that assist in working with the data in
the models. Each model class represents a table in the database used by this
application.

There are some shorthand terms that are used in docs in this module, and in
naming instances of models throughout the rest of sgs_flask.

Notes:
    Shorthand:

    In the docs, these shorthand terms are used to describe relationships:
        OtM - One to Many
        MtO - Many to One
        MtM - Many to Many
        OtO - One to One

    When creating instances of various models, it is often easier to use
    shorthand versions of their names, which are typically created by removing
    as many characters from the name as possible while still keeping it
    distinct and (hopefully) fairly obvious. The most common ones:
        idx - Index
        cn - CommonName
        bn - BotanicalName
        sec - Section
        cv - Cultivar
        pkt - Packet
        qty - Quantity

    Common Attributes Not Documented in Class Docstrings:

    All models contain the attributes __tablename__ and id, but they're not
    documented in each model, as they're fairly straightforward and obvious if
    one is familiar with SQLAlchemy. Just in case, though, here's what they
    are:
        __tablename__: The name of the table. This usually corresponds to the
            name of the model itself, eg the tablename for Index is 'indexes'.
        id: An integer used as the primary key for a model. It is automatically
            generated by SQLAlchemy when a new model instance is flushed to the
            database. While it's (usually) okay to set this value manually in
            tests, it should *never* be set manually in production code, as
            each id must be unique!

    Any attribute ending in _id is a foreign key used to create a relationship
    between two tables. In MtO and OtM relationships it will be defined right
    before the relationship it's for, and it will be named <relationship>_id.
    In MtM relationships, it will be specified in the appropriate association
    table.

    Grows With:

    Columns beginning with "gw_" represent that a CommonName or Cultivar grows
    well with other CommonNames or Cultivars. These are unidirectional
    relationships instead of bidirectional because they are used in generating
    grows with links, and we don't necessarily want A grows with B to create
    B grows with A, as it is often more important that customers know A grows
    with B than that B grows with A, so rather than clutter up pages with
    unnecessary grows with links that draw attention away from the important
    grows with links, we only want the important links to be generated.

"""

import datetime
import json
import os
import random
import re
import shutil
import sys
from decimal import Decimal
from pathlib import Path

from flask import current_app, url_for
from fractions import Fraction
from inflection import pluralize
from PIL import Image as Pimage
from slugify import slugify
from sqlalchemy import event, inspect
from sqlalchemy.ext.hybrid import Comparator, hybrid_property
from sqlalchemy.ext.orderinglist import ordering_list
from sqlalchemy.sql.expression import and_
from sqlalchemy_utils.types import TSVectorType
from sqlalchemy_searchable import SearchQueryMixin
from flask_sqlalchemy import BaseQuery, SignallingSession
from werkzeug.routing import BuildError

from app import db, html_fractions, list_to_english
from app.db_helpers import (
    OrderingListMixin,
    row_exists,
    TimestampMixin,
    USDollar
)


# Association Tables
indexes_to_images = db.Table(
    'indexes_to_images',
    db.Model.metadata,
    db.Column('index_id', db.Integer, db.ForeignKey('indexes.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


common_names_to_images = db.Table(
    'common_names_to_images',
    db.Model.metadata,
    db.Column('common_name_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


sections_to_images = db.Table(
    'sections_to_images',
    db.Model.metadata,
    db.Column('section_id', db.Integer, db.ForeignKey('sections.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


cultivars_to_images = db.Table(
    'cultivars_to_images',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


bulk_categories_to_images = db.Table(
    'bulk_categories_to_images',
    db.Model.metadata,
    db.Column('bulk_cat_id', db.Integer, db.ForeignKey('bulk_categories.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


bulk_series_to_images = db.Table(
    'bulk_series_to_images',
    db.Column('bulk_series_id', db.Integer, db.ForeignKey('bulk_series.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


bulk_items_to_images = db.Table(
    'bulk_items_to_images',
    db.Column('bulk_item_id', db.Integer, db.ForeignKey('bulk_items.id')),
    db.Column('images_id', db.Integer, db.ForeignKey('images.id'))
)


cultivars_to_custom_pages = db.Table(
    'cultivars_to_custom_pages',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('custom_pages_id', db.Integer, db.ForeignKey('custom_pages.id'))
)


cultivars_to_sections = db.Table(
    'cultivars_to_sections',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('section_id', db.Integer, db.ForeignKey('sections.id'))
)


common_names_to_gw_common_names = db.Table(
    'common_names_to_gw_common_names',
    db.Model.metadata,
    db.Column('parent_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('child_id', db.Integer, db.ForeignKey('common_names.id'))
)


common_names_to_gw_cultivars = db.Table(
    'common_names_to_gw_cultivars',
    db.Model.metadata,
    db.Column('common_name_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id'))
)


common_names_to_gw_sections = db.Table(
    'common_names_to_gw_sections',
    db.Model.metadata,
    db.Column('common_name_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('section_id', db.Integer, db.ForeignKey('sections.id'))
)


cultivars_to_gw_common_names = db.Table(
    'cultivars_to_gw_common_names',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('common_name_id', db.Integer, db.ForeignKey('common_names.id'))
)


cultivars_to_gw_cultivars = db.Table(
    'cultivars_to_gw_cultivars',
    db.Model.metadata,
    db.Column('parent_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('child_id', db.Integer, db.ForeignKey('cultivars.id'))
)


cultivars_to_gw_sections = db.Table(
    'cultivars_to_gw_sections',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('section_id', db.Integer, db.ForeignKey('sections.id'))
)


cultivars_to_states = db.Table(
    'cultivars_to_states',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('state_id', db.Integer, db.ForeignKey('states.id'))
)


cultivars_to_countries = db.Table(
    'cultivars_to_countries',
    db.Model.metadata,
    db.Column('cultivar_id', db.Integer, db.ForeignKey('cultivars.id')),
    db.Column('country_id', db.Integer, db.ForeignKey('countries.id'))
)


common_names_to_states = db.Table(
    'common_names_to_states',
    db.Model.metadata,
    db.Column('common_name_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('state_id', db.Integer, db.ForeignKey('states.id'))
)


common_names_to_countries = db.Table(
    'common_names_to_countries',
    db.Model.metadata,
    db.Column('common_name_id', db.Integer, db.ForeignKey('common_names.id')),
    db.Column('state_id', db.Integer, db.ForeignKey('countries.id'))
)


class SlugMixin:
    """A mixin for tables that should have a `slug` field for URL slugs.

    Note: Please remember to add  events to `auto_set_slug` (defined later
    in this module) for models using this mixin!

    Attributes:
        slug: A URL slug for the model instance.
    """
    slug = db.Column(db.UnicodeText)

    def make_slug(self):
        """Create a slug for object instance.

        Note: This assumes the attribute to make the slug from is `name`. If
        a different attribute is desired, override this method in the child
        class.

        Returns:
            A slugified version of `name` if present, otherwise `None`.
        """
        return slugify(self.name) or None


def dump_db_to_json(filename):
    """Save all data needed to copy the database into a JSON file."""
    d = dict()
    d['images'] = [i.dict_ for i in Image.query.all()]
    d['indexes'] = [i.dict_ for i in Index.query.all()]
    d['common names'] = [c.dict_ for c in CommonName.query.all()]

    with open(filename, 'w') as outfile:
        outfile.write(json.dumps(d, indent=4))


def populate_db_from_json(filename):
    """Populate a new db with data loaded from a JSON file."""
    with open(filename, 'r') as infile:
        d = json.loads(infile.read())
    for img_d in d['images']:
        db.session.add(Image.from_dict_(img_d))
    db.session.flush()
    for idx_d in d['indexes']:
        db.session.add(Index.from_dict_(idx_d))
    db.session.flush()
    for cn_d in d['common names']:
        db.session.add(CommonName.from_dict_(cn_d))
    db.session.flush()
    for cn_d in d['common names']:
        cn = CommonName.query.get(cn_d['id'])
        cn.gw_from_dict_(cn_d)
    db.session.flush()

    db.session.commit()


# Module-level Functions

def save_nav_data(json_file=None):
    if not json_file:
        json_file = Path(
            current_app.config.get('DATA_FOLDER'), 'nav_data.json'
        )
        if not json_file.parent.exists():
            json_file.parent.mkdir(parents=True)
    else:
        json_file = Path(json_file)
    indexes = Index.query.order_by('position').all()
    idx_list = []
    for idx in indexes:
        d = dict()
        d['Name'] = idx.name
        d['Position'] = idx.position
        d['Header'] = idx.plural  # We were using header, but changed it.
        d['id'] = idx.name.lower().replace(' ', '-')
        d['Slug'] = idx.slug
        d['URL'] = idx.url
        try:
            d['Thumbnail'] = idx.thumbnail.url
        except:
            d['Thumbnail'] = None
        d['Common Names'] = list()
        for cn in idx.common_names:
            cnd = dict()
            cnd['Position'] = cn.idx_pos
            cnd['Name'] = cn.name
            cnd['List As'] = cn.list_as
            cnd['URL'] = cn.url
            try:
                cnd['Thumbnail'] = cn.thumbnail.url
            except:
                cnd['Thumbnail'] = None
            d['Common Names'].append(cnd)
        idx_list.append(d)
    bulk_cats = BulkCategory.query.order_by('list_as').all()
    bulk = dict()
    bulk['Name'] = 'Bulk'
    bulk['Position'] = 1383
    bulk['Header'] = 'Bulk'
    bulk['id'] = 'bulk'
    bulk['Slug'] = 'bulk'
    bulk['URL'] = url_for('seeds.bulk', _external=True)
    bulk['Thumbnail'] = (
        'https://www.swallowtailgardenseeds.com/images/'
        'index-image-links/bulk-catalog3.jpg'
    )
    bulk['Common Names'] = list()
    for  cat in bulk_cats:
        catd = dict()
        catd['Poisition'] = bulk_cats.index(cat)
        catd['Name'] = cat.name
        catd['List As'] = cat.list_as
        catd['URL'] = cat.url
        catd['Thumbnail'] = None
        bulk['Common Names'].append(catd)
    idx_list.append(bulk)
    with json_file.open('w', encoding='utf-8') as ofile:
        ofile.write(json.dumps(idx_list, indent=4))


# Models
class IndexQuery(BaseQuery, SearchQueryMixin):
    pass


class Index(db.Model, SlugMixin, TimestampMixin):
    """Table for seed indexes.

    Indexes are the first/broadest divisions we use to sort seeds. The
    `Index` a seed falls under is usually based on what type of plant it is
    (herb, vegetable) or its life cycle. (perennial, annual)

    Attributes:
        position: An integer determining where an `Index` belongs in a list
            of `Index` instances. Inherited from `PositionableMixin`.

        name: The name for the `Index` itself, such as 'Herb'  or 'Perennial'.
        slug: A URL-safe version of `name`.

        thumbnail: An optional `Image` used as a thumbnail for a common name.
        description: An optional HTML description of the `Index`.
        common_names: Optional `CommonName` instances belonging to an `Index`.
    """
    query_class = IndexQuery
    __tablename__ = 'indexes'
    id = db.Column(db.Integer, primary_key=True)
    position = db.Column(db.Integer)

    # Data Required
    name = db.Column(db.UnicodeText)

    # Override slug to add unique constraint
    slug = db.Column(db.UnicodeText, unique=True)

    # Data Optional
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship('Image', back_populates='indexes_with_thumb')
    images = db.relationship(
        'Image',
        secondary=indexes_to_images,
        back_populates='indexes'
    )
    description = db.Column(db.UnicodeText)
    common_names = db.relationship(
        'CommonName',
        order_by='CommonName.idx_pos',
        collection_class=ordering_list('idx_pos', count_from=1),
        back_populates='index'
    )
    # Search
    search_vector = db.Column(
        TSVectorType('name', 'description',
                     weights={'name': 'A', 'description': 'B'})
    )

    def __init__(self, name=None, description=None):
        """Construct an instance of Index.

        Args:
            name: The name of the Index.
            description: An optional HTML description of this Index.
        """
        self.name = name
        self.description = description

    def __repr__(self):
        return '<{0} "{1}">'.format(self.__class__.__name__,
                                    self.name)

    def __eq__(self, other):
        return all((
            self.id == other.id,
            self.position == other.position,
            self.name == other.name,
            self.slug == other.slug,
            self.description == other.description
        )) if isinstance(other, Index) else False  # other can be None.

    def __hash__(self):  # pragma: no cover
        return hash(self.id)

    @property
    def url(self):
        """Return the URL for the main page for a given `Index`."""
        try:
            return url_for('seeds.index', idx_slug=self.slug, _external=True)
        except BuildError:
            return ''

    @property
    def dict_(self):
        """Return a dictionary of values needed to instantiate an `Index`.

        Note:
            Relationships with rows expected to be created after this are
            intentionally left out. They will be dealt with in their respective
            models.
        """
        return dict(
            id=self.id,
            position=self.position,
            name=self.name,
            slug=self.slug,
            thumbnail_id=self.thumbnail_id,
            description=self.description
        )

    @classmethod
    def from_dict_(cls, dict_):
        """Return a loaded or created `Index` using values from dict_.

        Note:
            This function should only be used during initial database
            population, it should not be used on a populated database!

        Args:
            dict_: A dictionary generated by `Index.dict_`.
        """
        idx = cls.query.get(dict_['id'])
        if idx:
            raise ValueError(
                'An Index with id {0} already exists as: "{0}"'
                .format(idx.id, idx.name)
            )
        idx = cls()
        for key in dict_.keys():
            if key == 'thumbnail_id' and dict_[key] is not None:
                idx.thumbnail = Image.query.get(dict_[key])
            else:
                idx.__setattr__(key, dict_[key])
        return idx

    @classmethod
    def get_or_create(cls, name, stream=sys.stdout):
        """Load an `Index` if it exists, create it if not.

        Note:
            The boolean attribute 'created' is attached to the `Index`
                instance so we know whether the returned Index was created or
                loaded.

        Args:
            name: The name of the `Index` to query or create.
            stream: Optional IO stream to write messages to.

        Returns:
            Index: The `Index` loaded/created.
        """
        idx = cls.query.filter(cls.name == name).one_or_none()
        if idx:
            print('The Index "{0}" has been loaded from the database.'
                  .format(idx.name), file=stream)
            idx.created = False
        else:
            idx = cls(name=name)
            print('The Index "{0}" does not yet exist in the database, so '
                  'it has been created.'.format(idx.name), file=stream)
            idx.created = True
        return idx

    @property
    def header(self):
        """str: contents of `name` in a str for headers, titles, etc."""
        # TODO : Maybe make the string setable via config?
        return '{0} Seeds'.format(self.name)

    @property
    def plural(self):
        """str: plural form of `name`."""
        return pluralize(self.name) if self.name is not None else None

    # Positioning methods and properties.
    #
    # Since Indexes aren't part of any collection, unfortunately they can't be
    # positioned using an ordering list.
    @property
    def positionable_instances(self):
        """Return a list of all instances of `Index` in both db and session.

        Returns:
            list: All active instances of `Index`.
        """
        rows = Index.query.all()
        rows += [i for i in db.session.new if isinstance(i, Index)]
        return rows

    def clean_positions(self, remove_self=False):
        """Re-number positions to account for gaps and inconsistencies.

        Args:
            remove_self: True if the instance `self` should be removed from
                the list of active instances before cleaning. This should
                only be set to True if `self` is being moved to a different
                parent, or being deleted from the database.
        """
        rows = self.positionable_instances
        if remove_self:
            rows.pop(rows.index(self))
        if rows:
            for row in rows:
                if row.position is None:
                    row.auto_position()
            sorted_rows = sorted(rows, key=lambda x: x.position)
            for i, row in enumerate(sorted_rows, 1):
                row.position = i

    def auto_position(self):
        """Automatically position an instance.

        This should generally only be run when adding a new instance, otherwise
        it should do nothing.
        """
        if not self.position:
            last = self.last
            if last:
                self.position = last.position + 1
            else:
                self.position = 1

    def set_position(self, position):
        """Manually set position of instance, and change position of others."""
        if self.position != position:
            rows = self.positionable_instances
            pruned_rows = [r for r in rows if r.position is not None]
            if pruned_rows:
                first = min(pruned_rows, key=lambda x: x.position)
                last = max(pruned_rows, key=lambda x: x.position)
                if position < first.position:
                    position = first.position
                if position > last.position + 1:
                    position = last.position + 1
                for r in pruned_rows:
                    if r.position >= position:
                        r.position += 1
                self.position = position
                if self not in pruned_rows:
                    pruned_rows.append(self)
                pruned_rows = sorted(pruned_rows, key=lambda x: x.position)
                for i, r in enumerate(pruned_rows, 1):
                    r.position = i
            else:
                self.auto_position()

    # Navigation methods
    def _step(self, forward=True):
        """Return next or previous instance by position.

        Args:
            forward: True if getting next instance, False if previous.

        Returns:
            The next or previous instance, or None if there is no next or
            previous instance.
        """
        cur_pos = self.position
        if forward:
            end_pos = self.last.position
        else:
            end_pos = self.first.position
        inst = None
        while inst is None:
            if cur_pos == end_pos:
                break

            if forward:
                cur_pos += 1
            else:
                cur_pos -= 1
            inst = Index.query.filter(Index.position == cur_pos).first()

        return inst

    @property
    def first(self):
        """Get the first instance according to position.

        Returns:
            The lowest positioned instance of <parent class>.
        """
        return min(self.positionable_instances,
                   key=lambda x: x.position,
                   default=None)

    @property
    def previous(self):
        """Get the previous instance according to position.

        Returns:
            The previous instance, or None if this instance is first.
        """
        return self._step(forward=False)

    @property
    def next(self):
        """Get the next instance according to position.

        Returns:
            The next instance, or None if this instance is last.
        """
        return self._step(forward=True)

    @property
    def last(self):
        """Get the last instance according to position.

        Returns:
            The highest positioned instance of <parent class>.
        """
        rows = self.positionable_instances
        pruned_rows = [r for r in rows if r and r.position is not None]
        return max(pruned_rows,
                   key=lambda x: x.position,
                   default=None)


class CommonNameQuery(BaseQuery, SearchQueryMixin):
    pass


class CommonName(db.Model, OrderingListMixin, SlugMixin, TimestampMixin):
    """Table for common names.

    A `CommonName` is the next subdivision below `Index` in how we sort seeds.
    It is usually the common name for the species or group of species a seed
    belongs to.

    Attributes:
        idx_pos: The position an instance of `CommonName` has relative to other
            `CommonName` instances belonging to the same `Index`. Automatically
             set by the relationship `Index.common_names`.

        index: The `Index` a `CommonName` instance belongs to.
        name: The common name of a seed. Examples: Coleus, Tomato,
            Lettuce, Zinnia.

        thumbnail: An optional thumbnail `Image`.
        description: An optional HTML description.
        instructions: Optional planting instructions for seeds with the
            specified CommonName.
        grows_with: Other `CommonName` instances that grow well with the
            given instance.
        visible: Whether or not to list given `CommonName` on non-custom pages.
            Default value: True.
        botanical_names: Botanical names belonging to given `CommonName`.
        sections: `Section` instances belonging to given `CommonName`.
        cultivars: `Cultivar` instances belonging to given `CommonName`.
    """
    query_class = CommonNameQuery
    __tablename__ = 'common_names'
    __table_args__ = (db.UniqueConstraint('name',
                                          'index_id',
                                          name='cn_name_index_uc'),
                      db.UniqueConstraint('slug',
                                          'index_id',
                                          name='cn_slug_index_uc'))
    id = db.Column(db.Integer, primary_key=True)

    # Position
    idx_pos = db.Column(db.Integer)

    # Data Required
    index_id = db.Column(db.Integer, db.ForeignKey('indexes.id'))
    index = db.relationship('Index', back_populates='common_names')
    name = db.Column(db.UnicodeText)
    list_as = db.Column(db.UnicodeText)

    # Data Optional
    subtitle = db.Column(db.UnicodeText)
    sunlight = db.Column(db.UnicodeText)
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship(
        'Image',
        back_populates='common_names_with_thumb'
    )
    images = db.relationship(
        'Image',
        secondary=common_names_to_images,
        back_populates='common_names'
    )
    botanical_names = db.Column(db.UnicodeText)
    description = db.Column(db.UnicodeText)
    instructions = db.Column(db.UnicodeText)
    visible = db.Column(db.Boolean)
    gw_common_names = db.relationship(
        'CommonName',
        secondary=common_names_to_gw_common_names,
        primaryjoin=id == common_names_to_gw_common_names.c.parent_id,
        secondaryjoin=id == common_names_to_gw_common_names.c.child_id
    )
    gw_sections = db.relationship(
        'Section',
        secondary=common_names_to_gw_sections
    )
    gw_cultivars = db.relationship(
        'Cultivar',
        secondary=common_names_to_gw_cultivars
    )
    sections = db.relationship(
        'Section',
        foreign_keys='Section.common_name_id',
        back_populates='common_name'
    )
    child_sections = db.relationship(
        'Section',
        order_by='Section.cn_pos',
        collection_class=ordering_list('cn_pos', count_from=1),
        foreign_keys='Section.parent_common_name_id',
        back_populates='parent_common_name'
    )
    cultivars = db.relationship(
        'Cultivar',
        foreign_keys='Cultivar.common_name_id',
        back_populates='common_name'
    )
    child_cultivars = db.relationship(
        'Cultivar',
        order_by='Cultivar.cn_pos',
        foreign_keys='Cultivar.parent_common_name_id',
        collection_class=ordering_list('cn_pos', count_from=1),
        back_populates='parent_common_name'
    )
    noship_states = db.relationship(
        'State',
        secondary=common_names_to_states,
        backref='noship_common_names'
    )
    noship_countries = db.relationship(
        'Country',
        secondary=common_names_to_countries,
        backref='noship_common_names'
    )
    # Search
    search_vector = db.Column(
        TSVectorType(
            'name',
            'list_as',
            'subtitle',
            'description',
            'instructions',
            'botanical_names',
            weights={
                'name': 'A',
                'list_as': 'A',
                'subtitle': 'B',
                'botanical_names': 'B',
                'description': 'C',
                'instructions': 'D'
            }
        )
    )

    def __init__(self,
                 name=None,
                 index=None,
                 description=None,
                 instructions=None,
                 visible=None):  # pragma: no cover
        """Construct an instance of `CommonName`."""
        self.name = name
        self.index = index
        self.description = description
        self.instructions = instructions
        if visible is not None:  # Do not override default value
            self.visible = visible

    def __repr__(self):
        return '<{0} "{1}">'.format(self.__class__.__name__, self.name)

    def __eq__(self, other):
        return all((
            self.id == other.id,
            self.index == other.index,
            self.name == other.name,
            self.slug == other.slug,
            self.description == other.description,
            self.instructions == other.instructions,
            self.gw_common_names == other.gw_common_names,
            self.gw_cultivars == other.gw_cultivars,
            self.visible == other.visible
        )) if isinstance(other, CommonName) else False

    def __hash__(self):
        return hash(self.id)

    @property
    def parent_collection(self):
        """Return the collection `CommonName` instances are ordered in."""
        if self.index:
            return self.index.common_names
        else:
            return None

    @property
    def url(self):
        try:
            return url_for(
                'seeds.common_name',
                cn_slug=self.slug,
                idx_slug=self.index.slug,
                _external=True
            )
        except BuildError:
            return ''

    @property
    def link_html(self):
        return '<a href="{0}">{1}</a>'.format(self.url, self.name)

    @property
    def grows_with(self):
        """Return all objects a `CommonName` grows with."""
        return self.gw_common_names + self.gw_sections + self.gw_cultivars

    @property
    def gw_common_names_ids(self):
        """Return list of ids of `gw_common_names`."""
        return [gwcn.id for gwcn in self.gw_common_names]

    @property
    def gw_cultivars_ids(self):
        """Return list of ids of `gw_cultivars`."""
        return [gwcv.id for gwcv in self.gw_cultivars]

    @property
    def gw_sections_ids(self):
        """Return list of ids of `gw_sections`."""
        return [gws.id for gws in self.gw_sections]

    @property
    def dict_(self):
        """Return a dictionary of values needed to duplicate `CommonName`."""
        return dict(
            id=self.id,
            index_id=self.index_id,
            name=self.name,
            slug=self.slug,
            description=self.description,
            instructions=self.instructions,
            gw_common_names=[cn.id for cn in self.gw_common_names],
            gw_cultivars=[cv.id for cv in self.gw_cultivars],
            visible=self.visible
        )

    @property
    def noship_states_html(self):
        """str: A list of states a `CommonName` can't be shipped to."""
        if self.noship_states:
            return '{} seeds cannot ship to {}.'.format(
                self.name,
                list_to_english(
                    [s.html for s in self.noship_states],
                    ', or '
                )
            )
        else:
            return ''

    @classmethod
    def get_or_create(cls, name, index, stream=sys.stdout):
        """Load a `CommonName` if it exists, create it if not.
        Returns:
            CommonName: The `CommonName` loaded or created.
        """
        cn = cls.query.filter(
            cls.index_id == index.id
        ).filter(
            cls.name == name
        ).one_or_none()
        if cn:
            print('The CommonName "{0}" has been loaded from the database.'
                  .format(cn.name), file=stream)
            cn.created = False
        else:
            cn = cls(name=name, index=index)
            print('The CommonName "{0}" does not yet exist in the database, '
                  'so it has been created.'.format(cn.name), file=stream)
            cn.created = True
        return cn

    @classmethod
    def get_orphans(cls):
        """Get all`CommonName` instances which don't belong to an `Index`."""
        return cls.query.filter(cls.index_id == None).all()

    @classmethod
    def from_dict_(cls, dict_):
        """Create a new `CommonName` from a dict provided by dict_.

        Note:

        `grows_with` is NOT handled by this function, as it requires all
        `CommonName` instances already exist in the database. Use the
        `CommonName.gw_from_dict_` function to set `grows_with` after
        all `CommonName` instances have been flushed or committed to db.
        """
        cn = cls.query.get(dict_['id'])
        if cn:
            raise ValueError(
                'A CommonName with the id {0} already exists as: "{1}"'
                .format(cn.id, cn.name)
            )

        cn = cls()
        for key in dict_.keys():
            if key == 'index_id':
                cn.index = Index.query.get(dict_[key])
            elif key != 'grows_with':
                cn.__setattr__(key, dict_[key])
        return cn

    def gw_from_dict_(self, dict_):
        """Set grows_with based on information in `dict_`.

        Warning:
            This function should only be run after all CommonName instances
            have been loaded into the database!
        """
        for gwcn_id in dict_['gw_common_names']:
            gw = CommonName.query.get(gwcn_id)
            if not gw:
                raise RuntimeError('No CommonName exists with the id: {0}'
                                   .format(gwcn_id))
            self.gw_common_names.append(gw)
        for gwcv_id in dict_['gw_cultivars']:
            gw = Cultivar.query.get(gwcv_id)
            if not gw:
                raise RuntimeError('No Cultivar exists with the id: {0}'
                                   .format(gwcv_id))
            self.gw_cultivars.append(gw)

    @classmethod
    def from_ids(cls, ids):
        """Return a list of `CommonName` instances with `ids`.

        Args:
            ids: A collection of `CommonName.id` values to query for.

        Returns:
            list: A list of `CommonName` instances each with an id in `ids`.
        """
        return [cls.query.get(id) for id in ids]

    @classmethod
    def from_queryable_values(cls, name, index):
        """Return a `CommonName` instance filtered by `name` and `index`.

        Args:
            name: The name of the `CommonName` instance to query for.
            index: The name of the `Index` the `CommonName` instance being
                queried for belongs to.

        Returns:
            CommonName: A discrete instance of `CommonName`.
        """
        return cls.query\
            .join(Index, Index.id == cls.index_id)\
            .filter(cls.name == name, Index.name == index)\
            .one_or_none()

    @classmethod
    def from_queryable_dict(cls, d):
        """Return a `CommonName` instance with information from a dict.

        Args:
            d: A dict containing the name and index name of a `CommonName`.

        Returns:
            CommonName: A discrete instance of `CommonName`.
        """
        return cls.from_queryable_values(name=d['Common Name'],
                                         index=d['Index'])

    @property
    def fullname(self):
        """str: The name of the `CommonName`.

        Note: This is a convenience property so that when mixing `CommonName`
        instances with `Cultivar` instances we can just use the `fullname`
        property to get the correct name for either.
        """
        return self.name

    @property
    def header(self):
        """str: `name` formatted for headers and titles."""
        if self.name:
            return '{0} Seeds'.format(self.name.title())
        else:
            return ''

    @property
    def select_field_title(self):
        """str: The title to use for a given `CommonName` in select fields."""
        if self.index and self.index.name:
            return '{0} ({1})'.format(self.name, self.index.name)
        else:
            return self.name

    @property
    def queryable_dict(self):
        """dict: The values needed to query a discrete `Cultivar` instance."""
        return {
            'Common Name': self.name,
            'Index': self.index.name if self.index else None
        }

    @property
    def has_public_cultivars(self):
        """bool: Whether or not `CommonName` has any public cultivars."""
        return self.cultivars and any(cv.public for cv in self.cultivars)


class SectionQuery(BaseQuery, SearchQueryMixin):
    pass


class Section(db.Model, OrderingListMixin, SlugMixin, TimestampMixin):
    """Table for sections cultivars may fall under.

    Sections are subdivisions of a common name which contain cultivars, such
    as the series a cultivar belongs to (e.g. the 'Sparkler' series contains
    the cultivars 'Sparkler White Cleome' and 'Sparkler Lavender Cleome') or
    some characteristic that is useful to know, such as whether cultivars are
    dwarf varieties, or for cut flowers.


    Attributes:
        cn_pos: The position of the `Section' relative to its parent
            `CommonName` instance.
        parent_pos: The position of the `Section` relative to its parent
            `Section`.

        name: The name of the section.
        common_name: The `CommonName` the `Section` belongs to.

        botanical_names: Optional botanical names for the `Section`.
        subtitle: Optional subtitle for `Section`.
        description: HTML description/intro for `Section`.
        parent: Optional parent `Section` the given `Section` is a subsection
            of.
        children: Optional child `Section` instances that are subsections of
            given `Section`.
        cultivars: `Cultivar` instances in given `Section`.
    """
    query_class = SectionQuery
    __tablename__ = 'sections'
    __table_args__ = (db.UniqueConstraint('name',
                                          'common_name_id',
                                          name='_section_name_cn_uc'),)
    id = db.Column(db.Integer, primary_key=True)

    # Positions
    cn_pos = db.Column(db.Integer)
    sec_pos = db.Column(db.Integer)

    # Data Required
    name = db.Column(db.UnicodeText)
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship(
        'CommonName',
        foreign_keys=[common_name_id],
        back_populates='sections'
    )

    # Data Optional
    parent_common_name_id = db.Column(
        db.Integer, db.ForeignKey('common_names.id')
    )
    parent_common_name = db.relationship(
        'CommonName',
        foreign_keys=[parent_common_name_id],
        back_populates='child_sections'
    )
    botanical_names = db.Column(db.UnicodeText)
    subtitle = db.Column(db.UnicodeText)
    description = db.Column(db.UnicodeText)
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship(
        'Image',
        back_populates='sections_with_thumb'
    )
    images = db.relationship(
        'Image',
        secondary=sections_to_images,
        back_populates='sections'
    )
    parent_id = db.Column(db.Integer, db.ForeignKey('sections.id'))
    parent = db.relationship(
        'Section', remote_side=[id], back_populates='children'
    )
    children = db.relationship(
        'Section',
        order_by='Section.sec_pos',
        collection_class=ordering_list('sec_pos', count_from=1),
        back_populates='parent'
    )
    cultivars = db.relationship(
        'Cultivar',
        secondary=cultivars_to_sections,
        back_populates='sections'
    )
    child_cultivars = db.relationship(
        'Cultivar',
        foreign_keys='Cultivar.parent_section_id',
        order_by='Cultivar.sec_pos',
        collection_class=ordering_list('sec_pos', count_from=1),
        back_populates='parent_section'
    )
    # Search
    search_vector = db.Column(
        TSVectorType(
            'name',
            'subtitle',
            'description',
            'botanical_names',
            weights={
                'name': 'A',
                'subtitle': 'B',
                'botanical_names': 'B',
                'description': 'C'
            }
        )
    )

    def __init__(self,
                 name=None,
                 common_name=None,
                 description=None,
                 position=None):
        """Create an instance of a Section."""
        self.name = name
        self.common_name = common_name
        self.description = description
        if position is not None:
            self.position = position

    def __repr__(self):
        """Return a string representing a `Section` instance."""
        return '<{0} "{1}">'.format(self.__class__.__name__, self.fullname)

    @property
    def url(self):
        try:
            return url_for(
                'seeds.common_name',
                cn_slug=self.common_name.slug,
                idx_slug=self.common_name.index.slug,
                _anchor=self.slug,
                _external=True
            )
        except BuildError:
            return ''

    @property
    def link_html(self):
        return '<a href="{0}">{1}</a>'.format(self.url, self.fullname)

    @property
    def parent_collection(self):
        if self.parent:
            return self.parent.children
        elif self.common_name:
            return self.common_name.child_sections
        else:
            return None

    @property
    def fullname(self):
        """str: Name of `Section` with name of `CommonName`."""
        fn = []
        if self.name:
            fn.append(self.name)
        if self.common_name:
            fn.append(self.common_name.name)
        if fn:
            return ' '.join(fn)
        else:
            return None

    @property
    def has_public_cultivars(self):
        """bool: Whether or not `Section` has any public cultivars."""
        rv = False
        if self.cultivars:
            if any(cv.public for cv in self.cultivars):
                rv = True
            if all(cv.featured for cv in self.cultivars):
                rv = False
        elif self.children:
            if any(child.has_public_cultivars for child in self.children):
                rv = True
        return rv

    @classmethod
    def from_ids(cls, ids):
        """Return a list of `Section` instances with `ids`.

        Args:
            ids: A collection of `Section.id` values to query for.

        Returns:
            list: A list of `Section` instances each with an id in `ids`.
        """
        return [cls.query.get(id) for id in ids]

    @classmethod
    def get_or_create(cls, name, common_name,  stream=sys.stdout):
        """Load a `Section` from the db, or create it if it doesn't exist.

        Args:
            name: The name of the `Section`.
            common_name: The `CommonName` it belongs to.
            stream: Buffer to output messages to.

        Returns:
            Section: The loaded or created `Section`.
        """
        sec = cls.query.filter(
            cls.common_name_id == common_name.id
        ).filter(
            cls.name == name
        ).one_or_none()
        if sec:
            sec.created = False
            print('The Section "{0}" has been loaded from the database.'
                  .format(sec.fullname), file=stream)
        else:
            sec = Section(name=name, common_name=common_name)
            sec.created = True
            print('The Section "{0}" does not yet exist in the database, '
                  'so it has been created'.format(sec.fullname), file=stream)
        return sec

    @classmethod
    def get_orphans(cls):
        """Get all `Section` instances with no `CommonName`."""
        return cls.query.filter(cls.common_name_id == None).all()

    def set_common_name(self, cn, insert_at=None):
        """Set common_name and deal with positioning.

        Args:
            cn: The CommonName to set.
        """
        if cn is not None:
            if insert_at is None or insert_at > len(cn.child_sections):
                insert_at = len(cn.child_sections)
            self.common_name = cn
            self.parent = None
            if self not in cn.child_sections:
                cn.child_sections.insert(insert_at, self)
            else:
                csecs = cn.child_sections
                csecs.insert(insert_at, csecs.pop(csecs.index(self)))
        else:
            self.common_name = None
            self.parent_common_name = None

    def set_parent(self, other, insert_at=None):
        """Set other as parent, and deal with positioning."""
        if other is not self:
            if other is not None:
                self.parent_common_name = None
                if insert_at is None or insert_at > len(other.children):
                    insert_at = len(other.children)
                if self not in other.children:
                    other.children.insert(insert_at, self)
                else:
                    oc = other.children
                    oc.insert(insert_at, oc.pop(oc.index(self)))
            else:
                self.parent = None
                self.parent_common_name = self.common_name
        else:
            raise ValueError('Cannot set section as its own parent!')


class CultivarQuery(BaseQuery, SearchQueryMixin):
    pass


class Cultivar(db.Model, OrderingListMixin, SlugMixin, TimestampMixin):
    """Table for cultivar data.

    A cultivar is an individual variety of plant, and represents the most
    specific category seeds fall under. This is the primary attribute that
    products (packets) are attached to.

    Note:
        A cultivar must have a unique combination of name and common name,
        otherwise it could result in multiple results from a query intended to
        fetch only one cultivar.

    Attributes:
        cn_pos: Position relative to parent `CommonName`.
        sec_pos: Position relative to parent `Section`.

        name: The name of the cultivar, without common name. e.g. 'Sparkler
            White' for Sparkler White Cleome.
        common_name: The `CommonName` a `Cultivar` belongs to.

        subtitle: An optional subtitle for cases in which the subtitle under
            a `Cultivar` on a page should be something other than
            '<`Cultivar.common_name.name`> Seeds', as in Fuseables, e.g.
            'Bacopa/Petunia Multi-Species Seeds'.
        section: Optional `Section` a `Cultivar` belongs to.
        botanical_name: The botanical name of given `Cultivar`.
        description: An optional HTML description of a cultivar.
        new_until: The year a `Cultivar` is new for, if applicable.
        featured: Whether or not `Cultivar` should be featured on its common
            name page.
        active: True if the cultivar's stock is being actively replenished,
            False if not.
        in_stock: True if a cultivar is in stock, False if not.
        visible: Whether or not this cultivar should be shown on automatically
            generated pages. Cultivars with `visible` set to `False` can still
            be shown on custom pages.
        taxable: Whether or not seeds of a cultivar are taxable in the state
            of California.
        thumbnail: An optional thumbnail `Image` for a `Cultivar`.
        images: `Image` instances which are not thumbnails, but which are
            associated with a `Cultivar`.
        packets: The seed `Packet` instances belonging to given `Cultivar`.
        synonyms: Synonyms for a `Cultivar`.
        custom_pages: `CustomPage` instances that include given `Cultivar`.
    """
    query_class = CultivarQuery
    __tablename__ = 'cultivars'
    id = db.Column(db.Integer, primary_key=True)
    __table_args__ = (db.UniqueConstraint('name',
                                          'common_name_id',
                                          name='_cultivar_name_cn_uc'),)

    # Positions
    cn_pos = db.Column(db.Integer)
    sec_pos = db.Column(db.Integer)

    # Data Required
    name = db.Column(db.UnicodeText)
    common_name_id = db.Column(db.Integer, db.ForeignKey('common_names.id'))
    common_name = db.relationship(
        'CommonName',
        foreign_keys=common_name_id,
        back_populates='cultivars')

    # Data Optional
    subtitle = db.Column(db.UnicodeText)
    section_id = db.Column(db.Integer, db.ForeignKey('sections.id'))
    sections = db.relationship(
        'Section',
        secondary=cultivars_to_sections,
        back_populates='cultivars'
    )
    botanical_name = db.Column(db.UnicodeText)
    organic = db.Column(db.Boolean)
    open_pollinated = db.Column(db.Boolean)
    maturation = db.Column(db.UnicodeText)
    description = db.Column(db.UnicodeText)
    new_for = db.Column(db.Integer)
    featured = db.Column(db.Boolean)
    favorite = db.Column(db.Boolean)
    active = db.Column(db.Boolean)
    in_stock = db.Column(db.Boolean)
    visible = db.Column(db.Boolean)
    taxable = db.Column(db.Boolean)
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship(
        'Image',
        foreign_keys=thumbnail_id,
        back_populates='cultivars_with_thumb'
    )
    images = db.relationship(
        'Image',
        secondary=cultivars_to_images,
        back_populates='cultivars'
    )
    packets = db.relationship(
        'Packet',
        cascade='all, delete-orphan',
        back_populates='cultivar'
    )
    gw_common_names = db.relationship(
        'CommonName',
        secondary=cultivars_to_gw_common_names
    )
    gw_cultivars = db.relationship(
        'Cultivar',
        secondary=cultivars_to_gw_cultivars,
        primaryjoin=id == cultivars_to_gw_cultivars.c.parent_id,
        secondaryjoin=id == cultivars_to_gw_cultivars.c.child_id
    )
    gw_sections = db.relationship(
        'Section',
        secondary=cultivars_to_gw_sections
    )
    custom_pages = db.relationship(
        'CustomPage',
        secondary=cultivars_to_custom_pages,
        back_populates='cultivars'
    )
    parent_common_name_id = db.Column(
        db.Integer,
        db.ForeignKey('common_names.id')
    )
    parent_common_name = db.relationship(
        'CommonName',
        foreign_keys=parent_common_name_id,
        back_populates='child_cultivars'
    )
    parent_section_id = db.Column(db.Integer, db.ForeignKey('sections.id'))
    parent_section = db.relationship(
        'Section',
        foreign_keys=parent_section_id,
        back_populates='child_cultivars'
    )
    noship_states = db.relationship(
        'State',
        secondary=cultivars_to_states,
        backref='noship_cultivars'
    )
    noship_countries = db.relationship(
        'Country',
        secondary=cultivars_to_countries,
        backref='noship_cultivars'
    )
    search_vector = db.Column(
        TSVectorType(
            'name',
            'subtitle',
            'botanical_name',
            'maturation',
            'description',
            weights={
                'name': 'A',
                'subtitle': 'B',
                'botanical_name': 'B',
                'maturation': 'C',
                'description': 'D'
            }
        )
    )

    def __init__(self,
                 name=None,
                 common_name=None,
                 section=None,
                 botanical_name=None,
                 description=None,
                 new_for=None,
                 active=None,
                 in_stock=None,
                 invisible=None):
        """Create an instance of Cultivar.

        Note:
            `images` and `thumbnail` have been left out because in practice
            they should have some work done to ensure they are set correctly.
        """
        self.name = name
        self.common_name = common_name
        self.section = section
        self.botanical_name = botanical_name
        self.description = description
        self.new_for = new_for
        if active is not None:
            self.active = active
        if in_stock is not None:
            self.in_stock = in_stock
        if invisible is not None:
            self.invisible = invisible

    def __repr__(self):
        """Return representation of Cultivar in human-readable format."""
        return '<{0} "{1}">'.format(self.__class__.__name__,
                                    self.fullname)

    def __getitem__(self, key):
        try:
            return getattr(self, key.replace(' ', '_'))
        except AttributeError:
            raise KeyError(key)

    def __setitem__(self, key, value):
        try:
            setattr(self, key.replace(' ', '_'), value)
        except AttributeError:
            raise KeyError(key)

    @property
    def url(self):
        # TODO: Integrate option for if cultivar pages are active.
        try:
            return url_for(
                'seeds.common_name',
                cn_slug=self.common_name.slug,
                idx_slug=self.common_name.index.slug,
                _anchor=self.slug,
                _external=True
            )
        except BuildError:
            return ''

    @property
    def link_html(self):
        return '<a href="{0}">{1}</a>'.format(self.url, self.fullname)

    @property
    def parent_collection(self):
        if self.parent_section:
            return self.parent_section.child_cultivars
        elif self.common_name:
            return self.common_name.child_cultivars
        else:
            return None

    @property
    def grows_with(self):
        """Return all objects a `Cultivar` grows with."""
        return self.gw_common_names + self.gw_sections + self.gw_cultivars

    @property
    def gw_common_names_ids(self):
        """Return list of ids of `gw_common_names`."""
        return [gwcn.id for gwcn in self.gw_common_names]

    @property
    def gw_sections_ids(self):
        """Return list of ids of `gw_sections`."""
        return [gws.id for gws in self.gw_sections]

    @property
    def gw_cultivars_ids(self):
        """Return list of ids of `gw_cultivars`."""
        return [gwcv.id for gwcv in self.gw_cultivars]

    @property
    def gw_links(self):
        return list_to_english((gw.link_html for gw in self.grows_with))

    @property
    def product_name(self):
        """Return a default product name for given `Cultivar`."""
        return '{}, {}'.format(self.common_name.name, self.name).upper()

    @property
    def fullname(self):
        """str: Full name of cultivar including common name."""
        fn = [self.name]
        if self.common_name and self.common_name.name != self.name:
            fn.append(self.common_name.name)
        if fn:
            return ' '.join(fn)
        else:
            return None

    @property
    def vegetable_info(self):
        """vegetable info formatted for display, if present."""
        if self.open_pollinated:
            op = '<abbr title="Open Pollinated">(OP)</abbr>'
            if self.maturation:
                return '{} {}'.format(op, self.maturation)
            else:
                return op
        elif self.maturation:
            return self.maturation
        else:
            return ''


    @property
    def queryable_dict(self):
        """dict: A dict with name, common_name, and index of `self`.

        Note:
            Any or all values can be `None`, as passing <obj.attribute> == None
            to db.Model.query.filter() will return `None` if no objects in the
            database have the attribute in question set to `None`. A `dict`
            with all values set to `None` won't raise an exception when used
            for a query, it will just yield no results.
        """
        name = self.name
        common_name = self.common_name.name if self.common_name else None
        index = (self.common_name.index.name if self.common_name
                 and self.common_name.index else None)
        return {
            'Cultivar Name': name,
            'Common Name': common_name,
            'Index': index
        }

    @property
    def public(self):
        """bool: Whether or not `Cultivar` is visible to non-admin users."""
        return self.active and self.visible

    @property
    def noship_states_html(self):
        """str: A list of states a `Cultivar` can't be shipped to."""
        if self.noship_states:
            return 'Cannot ship to {}.'.format(
                list_to_english(
                    [s.html for s in self.noship_states],
                    ', or '
                )
            )
        else:
            return ''

    @classmethod
    def from_ids(cls, ids):
        """Get `Cultivar` instances corresponding to `ids`.

        Args:
            ids: A collection of `Cultivar.id` to query.

        Returns:
            list: A list of `Cultivar` instances with given ids.
        """
        return [cls.query.get(id) for id in ids]

    @classmethod
    def from_queryable_values(cls, name, common_name, index):
        """Query a `Cultivar` from the database given its core values.

        The core values of a `Cultivar` are its name, its common name, the
        index it belongs to.

        Args:
            name: The name of the cultivar.
            common_name: The common name of the cultivar.
            index: The index the cultivar's common name (and thus the cultivar
                itself) falls under.

        Returns:
            Cultivar: A discrete instance of `Cultivar`.
            None: If no cultivar exists with the given parameters.
        """
        return cls.query\
            .join(CommonName, CommonName.id == cls.common_name_id)\
            .join(Index, Index.id == CommonName.index_id)\
            .filter(cls.name == name,
                    CommonName.name == common_name,
                    Index.name == index)\
            .one_or_none()

    @classmethod
    def from_queryable_dict(cls, d):
        """Query a `Cultivar` from db given its core values in a dict.

        Args:
            d: A dictionary containing the necessary values to query a discrete
                `Cultivar` from the database.

        Returns:
            Cultivar: A discrete instance of `Cultivar`.
            None: If no `Cultivar` exists with the given parameters.
        """
        return cls.from_queryable_values(name=d['Cultivar Name'],
                                         common_name=d['Common Name'],
                                         index=d['Index'])

    @classmethod
    def get_or_create(cls,
                      name,
                      common_name,
                      stream=sys.stdout):
        """Load a cultivar if it exists, create it if not.
        """
        cv = cls.query.filter(
            cls.common_name_id == common_name.id
        ).filter(
            cls.name == name
        ).one_or_none()
        if cv:
            cv.created = False
            print('The Cultivar "{0}" has been loaded from the database.'
                  .format(cv.fullname), file=stream)
        else:
            cv = cls(name=name, common_name=common_name)
            cv.created = True
            print('The Cultivar "{0}" does not yet exist in the database, '
                  'so it has been created.'.format(cv.fullname), file=stream)
        return cv

    @classmethod
    def get_orphans(cls):
        """Get all `Cultivar` instances with no `CommonName`."""
        return cls.query.filter(cls.common_name_id == None).all()


class Packet(db.Model, TimestampMixin):
    """Table for seed packet information.

    Packet information includes data for each individual type of packet we
    sell, such as the size and price of a given packet. Each seed can have
    multiple different associated packets, due to different sizes (such as
    jumbo) and prices associated with different packet sizes.

    Attributes:
        sku: Product SKU for the packet.
        price: Price (in US dollars) for this packet.
        amount: The amount of seeds in a packet.
        cultivar: The `Cultivar` a `Packet` belongs to.
    """
    __tablename__ = 'packets'
    id = db.Column(db.Integer, primary_key=True)
    sku = db.Column(db.UnicodeText, unique=True)
    product_name = db.Column(db.UnicodeText)
    price = db.Column(USDollar)
    amount = db.Column(db.UnicodeText)
    cultivar_id = db.Column(db.Integer, db.ForeignKey('cultivars.id'))
    cultivar = db.relationship('Cultivar', back_populates='packets')

    def __repr__(self):
        return '<{0} SKU #{1}>'.format(self.__class__.__name__, self.sku)

    def __init__(self, sku=None, price=None, amount=None, cultivar=None):
        """Create an instance of Packet.
        """
        self.sku = sku
        self.price = price
        self.amount = amount
        self.cultivar = cultivar

    @property
    def name(self):
        """str: `product_name`.

        This is a convenience so that generic functions that expect a `name`
        attribute can work with `Packet`.
        """
        return self.product_name

    @property
    def taxable(self):
        try:
            return self.cultivar.taxable
        except AttributeError:
            return False

    @property
    def info(self):
        """str: A formatted string containing the data of this packet."""
        return 'SKU #{0}: ${1} for {2}'.format(self.sku,
                                               self.price,
                                               self.amount)

    @property
    def label(self):
        """A label for a packet as used in the shopping cart."""
        try:
            return '{0}, {1} - {2}'.format(self.cultivar.common_name.name,
                                           self.cultivar.name,
                                           self.amount)
        except AttributeError:
            return ''

    @classmethod
    def get_or_create(cls, sku):
        pkt = cls.query.filter(cls.sku == sku).one_or_none()
        if not pkt:
            pkt = cls(sku=sku)
        return pkt

    @classmethod
    def get_orphans(cls):
        """Get all `Packet` instances with no `Cultivar`."""
        return cls.query.filter(cls.cultivar_id == None).all()


class CustomPage(db.Model, TimestampMixin):
    """Table for custom pages that cover edge cases.

    Since there will always be some edge cases in which we may want to create
    pages that can't easily be automatically generated (for example, a page
    that lists cultivars from multiple common names) this table allows for
    generic pages to be made.

    Attributes:
        title: Page title to be used in <title> and for queries.
        content: The HTML content of the page, including parseable tokens.
        cultivars: `Cultivar` instances to be listed on a `CustomPage`.
    """
    __tablename__ = 'custom_pages'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.UnicodeText, unique=True)
    content = db.Column(db.UnicodeText)
    cultivars = db.relationship(
        'Cultivar',
        secondary=cultivars_to_custom_pages,
        back_populates='custom_pages'
    )


class ImageQuery(BaseQuery, SearchQueryMixin):
    pass


class Image(db.Model, TimestampMixin):
    """Table for image information.

    Any image uploaded to be used with the cultivar model should utilize this
    table for important image data like filename and location.

    Attributes:
        filename: File name of an image.

        index: The `Index` an `Image` is thumbnail for.
        common_name: The `CommonName` an `Image` is thumbnail for.
        cultivar: The `Cultivar` an `Image` is thumbnail for.
        cultivars: `Cultivar` instances an image is not thumbnail for, but
            still associated with.

    """
    __tablename__ = 'images'
    query_class = ImageQuery
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.UnicodeText, unique=True)
    width = db.Column(db.Integer)
    height = db.Column(db.Integer)

    # relationships
    indexes_with_thumb = db.relationship(
        'Index',
        back_populates='thumbnail'
    )
    indexes = db.relationship(
        'Index',
        secondary=indexes_to_images,
        back_populates='images'
    )
    common_names_with_thumb = db.relationship(
        'CommonName',
        back_populates='thumbnail'
    )
    common_names = db.relationship(
        'CommonName',
        secondary=common_names_to_images,
        back_populates='images'
    )
    sections_with_thumb = db.relationship(
        'Section',
        back_populates='thumbnail'
    )
    sections = db.relationship(
        'Section',
        secondary=sections_to_images,
        back_populates='images'
    )
    cultivars_with_thumb = db.relationship(
        'Cultivar',
        back_populates='thumbnail'
    )
    cultivars = db.relationship(
        'Cultivar',
        secondary=cultivars_to_images,
        back_populates='images'
    )
    bulk_categories_with_thumb = db.relationship(
        'BulkCategory',
        back_populates='thumbnail'
    )
    bulk_categories = db.relationship(
        'BulkCategory',
        secondary=bulk_categories_to_images,
        back_populates='images'
    )
    bulk_series_with_thumb = db.relationship(
        'BulkSeries',
        back_populates='thumbnail'
    )
    bulk_series = db.relationship(
        'BulkSeries',
        secondary=bulk_series_to_images,
        back_populates='images'
    )
    bulk_items_with_thumb = db.relationship(
        'BulkItem',
        back_populates='thumbnail'
    )
    bulk_items = db.relationship(
        'BulkItem',
        secondary=bulk_items_to_images,
        back_populates='images'
    )
    # Search
    search_vector = db.Column(TSVectorType('filename'))

    def __init__(self, filename=None):
        if filename:
            self.filename = filename

    def __repr__(self):
        return '<{0} filename: "{1}">'.format(self.__class__.__name__,
                                              self.filename)

    @property
    def url(self):
        try:
            return url_for('static', filename=self.filename, _external=True)
        except BuildError:
            return ''

    @property
    def dict_(self):
        """Return dict with needed info to copy `Image`."""
        return {
            'id': self.id,
            'filename': self.filename
        }

    @property
    def subfolder(self):
        """Return the subfolder of static that the file is in."""
        return os.path.join(*os.path.split(self.filename)[:-1])

    @subfolder.setter
    def subfolder(self, val):
        """Change subfolder for image."""
        self.rename(self.filename.replace(self.subfolder, val))

    @property
    def path(self):
        """Path: The full path to the file this image entry represents."""
        return Path(current_app.config.get('STATIC_FOLDER'), self.filename)

    @classmethod
    def get_or_create(cls, filename):
        """Get an existing `Image` or create it if not present."""
        img = cls.query.filter(cls.filename == filename).one_or_none()
        if not img:
            img = cls(filename=filename)
            img.created = True
        else:
            img.created = False
        return img

    @classmethod
    def with_upload(cls, filename, upload):
        """Create an `Image` instance and upload the corresponding file."""
        img = cls.get_or_create(filename)
        img.path.parent.mkdir(parents=True, exist_ok=True)
        upload.save(str(img.path))
        return img

    @staticmethod
    def delete_empty_folders(path):
        """Delete empty folders in path if present."""
        if path.is_dir():
            p = path
        else:
            p = path.parent
        while p != Path(current_app.config.get('STATIC_FOLDER')):
            try:
                p.rmdir()
                p = p.parent
            except OSError:
                break

    def rename(self, filename):
        """Rename Image and move the corresponding file."""
        op = self.path
        self.filename = filename
        self.path.parent.mkdir(parents=True, exist_ok=True)
        op.rename(self.path)
        Image.delete_empty_folders(op)

    def exists(self):
        """Check whether or not file associated with this Image exists."""
        return self.path.exists()


class BulkCategory(db.Model, SlugMixin, TimestampMixin):
    """Table for bulk categories/sections."""
    __tablename__ = 'bulk_categories'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.UnicodeText)
    # Override slug to add unique constraint
    slug = db.Column(db.UnicodeText, unique=True)
    list_as = db.Column(db.UnicodeText)
    subtitle = db.Column(db.UnicodeText)
    
    series = db.relationship(
        'BulkSeries',
        order_by='BulkSeries.cat_pos',
        collection_class=ordering_list('cat_pos', count_from=1),
        back_populates='category'
    )
    items = db.relationship(
        'BulkItem',
        order_by='BulkItem.cat_pos',
        collection_class=ordering_list('cat_pos', count_from=1),
        back_populates='category'
    )
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship(
        'Image',
        back_populates='bulk_categories_with_thumb'
    )
    images = db.relationship(
        'Image',
        secondary=bulk_categories_to_images,
        back_populates='bulk_categories'
    )

    def __repr__(self):
        return '<BulkCategory "{}">'.format(self.name)

    @property
    def url(self):
        return url_for('seeds.bulk_category', slug=self.slug, _external=True)

    @property
    def title(self):
        name = self.name.title()
        if 'Bulk' not in name:
            name = 'Bulk ' + name
        if 'Seeds' not in name:
            name = name + ' Seeds'
        return name

    @property
    def item_groups(self):
        items = sorted(self.items, key = lambda x: x.name)
        current_series = items[0].series
        groups = []
        current_group = {'series': current_series, 'items': []}
        for item in items:
            if item.series is current_series:
                current_group['items'].append(item)
            else:
                groups.append(current_group)
                current_series = item.series
                current_group = {'series': current_series, 'items': [item]}
        if current_group not in groups:
            groups.append(current_group)
        return groups

    @classmethod
    def get_or_create(cls, slug):
        """Get `BulkCategory` with given slug, otherwise create it."""
        bc = cls.query.filter(cls.slug == slug).one_or_none()
        if not bc:
            bc = cls(slug=slug)
            bc.created = True
        else:
            bc.created = False
        return bc


class BulkSeries(db.Model, OrderingListMixin, SlugMixin, TimestampMixin):
    """Table for series within bulk categories/sections."""
    __tablename__ = 'bulk_series'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.UnicodeText)
    subtitle = db.Column(db.UnicodeText)

    cat_pos = db.Column(db.Integer)

    category_id = db.Column(db.Integer, db.ForeignKey('bulk_categories.id'))
    category = db.relationship('BulkCategory', back_populates='series')
    items = db.relationship(
        'BulkItem',
        order_by='BulkItem.ser_pos',
        collection_class=ordering_list('ser_pos', count_from=1),
        back_populates='series'
    )
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship(
        'Image',
        back_populates='bulk_series_with_thumb'
    )
    images = db.relationship(
        'Image',
        secondary=bulk_series_to_images,
        back_populates='bulk_series'
    )

    def __repr__(self):
        return '<BulkSeries "{}">'.format(self.name)

    @property
    def url(self):
        """str: A URL for the page this series is on."""
        return url_for(
            'seeds.bulk_category',
            slug=self.category.slug,
            _anchor=self.slug,
            _external=True
        )

    @property
    def short_name(self):
        """str: Name with 'series' removed."""
        return re.sub('(?i)series', '', self.name).strip()

    @property
    def items_after(self):
        """list: Items not in a series that come after this series."""
        serieses = self.category.series  # A perfectly cromulent word!
        try:
            n = serieses[serieses.index(self) + 1]
            return [
                i for i in self.category.items if self.name < i.name < n.name
            ]
        except IndexError:
            return []

    @classmethod
    def get_or_create(cls, cat, slug):
        """Get `BulkSeries` with given category and slug.

        Args:
            cat: The `BulkCategory` the `BulkSeries` belongs/should belong to.
            slug: The slug of the `BulkSeries` to get or create.
        """
        ser = next((s for s in cat.series if s.slug == slug), None)
        if not ser:
            ser = cls(category=cat, slug=slug)
            ser.created = True
        else:
            ser.created = False
        return ser


class BulkItem(db.Model, OrderingListMixin, SlugMixin, TimestampMixin):
    """Table for individual bulk items."""
    __tablename__ = 'bulk_items'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.UnicodeText)
    product_name = db.Column(db.UnicodeText)
    sku = db.Column(db.UnicodeText)
    price = db.Column(USDollar)
    taxable = db.Column(db.Boolean)

    cat_pos = db.Column(db.Integer)
    ser_pos = db.Column(db.Integer)

    category_id = db.Column(db.Integer, db.ForeignKey('bulk_categories.id'))
    category = db.relationship('BulkCategory', back_populates='items')
    series_id = db.Column(db.Integer, db.ForeignKey('bulk_series.id'))
    series = db.relationship('BulkSeries', back_populates='items')
    thumbnail_id = db.Column(db.Integer, db.ForeignKey('images.id'))
    thumbnail = db.relationship(
        'Image',
        back_populates='bulk_items_with_thumb'
    )
    images = db.relationship(
        'Image',
        secondary=bulk_items_to_images,
        back_populates='bulk_items'
    )

    def __repr__(self):
        return '<BulkItem "{}">'.format(self.name)

    @property
    def url(self):
        try:
            return url_for(
                'seeds.bulk_category',
                slug=self.category.slug,
                _anchor=self.slug
            )
        except AttributeError:
            return ''
    
    @classmethod
    def get_or_create(cls, category, slug):
        """Get `BulkItem` with given category and slug.

        Args:
            category: The `BulkCategory` the item belongs to.
            slug: The slug of the `BulkItem` to get or create.
        """
        item = next((i for i in category.items if i.slug == slug), None)
        if not item:
            item = cls(category=category, slug=slug)
            item.created = True
        else:
            item.created = False
        return item


# Event Listeners
@event.listens_for(SignallingSession, 'before_commit')
def save_nav_data_before_commit(session):
    """Save nav data if a commit would change a nav url."""
    if (any(isinstance(obj, Index) for obj in db.session) or
            any(isinstance(obj, CommonName) for obj in db.session) or
            any(isinstance(obj, BulkCategory) for obj in db.session)):
        save_nav_data()


@event.listens_for(SignallingSession, 'before_attach')
def auto_position_before_attach(session, instance):
    """Auto-generate positions for new instances of classes that have them."""
    if hasattr(instance, 'auto_position'):
        instance.auto_position()


@event.listens_for(Index, 'before_insert')
@event.listens_for(Index, 'before_update')
@event.listens_for(CommonName, 'before_insert')
@event.listens_for(CommonName, 'before_update')
@event.listens_for(Section, 'before_insert')
@event.listens_for(Section, 'before_update')
@event.listens_for(Cultivar, 'before_insert')
@event.listens_for(Cultivar, 'before_update')
@event.listens_for(BulkCategory, 'before_insert')
@event.listens_for(BulkCategory, 'before_update')
@event.listens_for(BulkSeries, 'before_insert')
@event.listens_for(BulkSeries, 'before_update')
@event.listens_for(BulkItem, 'before_insert')
@event.listens_for(BulkItem, 'before_update')
def auto_set_slug(mapper, connection, target):
    """Automatically set `slug` if an instance without one is added/updated.
    
    To add a model to this event handler, simply add these decorators:

        @event.listens_for(<model>, 'before_insert')
        @event.listens_for(<model>, 'after_insert')
    """
    if not target.slug:
        target.slug = target.make_slug()


@event.listens_for(Index.thumbnail, 'set')
@event.listens_for(CommonName.thumbnail, 'set')
@event.listens_for(Section.thumbnail, 'set')
@event.listens_for(Cultivar.thumbnail, 'set')
@event.listens_for(BulkSeries.thumbnail, 'set')
@event.listens_for(BulkItem.thumbnail, 'set')
def add_thumbnail_to_images(target, value, oldvalue, initiator):
    """Add `thumbnail` to `images` when setting it."""
    if value and value not in target.images:
        target.images.append(value)


# CommonName Event Listeners
@event.listens_for(CommonName, 'before_insert')
@event.listens_for(CommonName, 'before_update')
def auto_set_list_as(mapper, connection, target):
    """Set `list_as` if unset when adding/editing `CommonName`."""
    if not target.list_as:
        target.list_as = target.name


@event.listens_for(CommonName.sections, 'append')
def common_name_sections_appended(target, value, initiator):
    if not value.parent:
        value.parent_common_name = target


@event.listens_for(CommonName.sections, 'remove')
def common_name_sections_removed(target, value, initiator):
    value.parent_common_name = None


@event.listens_for(CommonName.cultivars, 'append')
def common_name_cultivars_appended(target, value, initiator):
    if not value.parent_section:
        target.child_cultivars.insert(len(target.child_cultivars), value)


@event.listens_for(CommonName.cultivars, 'remove')
def common_name_cultivars_removed(target, value, initiator):
    value.parent_common_name = None


# Section Event Listeners
@event.listens_for(Section.parent, 'set')
def section_parent_no_loop(target, value, oldvalue, initiator):
    """Do not allow a parent-child loop to be created.

    If a `Section` parent-child loop is created, it will cause endless loops
    when iterating through parent-child relationships.
    """
    parents = [target]
    p = value
    while p is not None:
        if value in parents:
            raise RuntimeError(
                'Setting {0} as parent to {1} would create a parent-child '
                'loop!'.format(value, target)
            )
        else:
            parents.append(p)
            p = p.parent


@event.listens_for(Section.children, 'append')
def section_children_appended(target, value, intiator):
    value.parent_common_name = None


@event.listens_for(Section.children, 'remove')
def section_children_removed(target, value, initiator):
    value.parent_common_name = value.common_name

@event.listens_for(Section.child_cultivars, 'append')
def section_child_cultivars_appended(target, value, intiator):
    value.parent_common_name = None


@event.listens_for(Section.child_cultivars, 'remove')
def section_child_cultivars_removed(target, value, initiator):
    if not value.sections:
        value.parent_common_name = value.common_name


@event.listens_for(Section.cultivars, 'append')
def section_cultivars_appended(target, value, initiator):
    if target.parent and value not in target.parent.cultivars:
        target.parent.cultivars.append(value)
    if not target.children or set(target.children).isdisjoint(value.sections):
        target.child_cultivars.insert(len(target.child_cultivars), value)


@event.listens_for(Section.cultivars, 'remove')
def section_cultivars_removed(target, value, initiator):
    print('removing parent {0} from {1}'.format(value, target))
    try:
        for c in target.children:
            try:
                c.cultivars.remove(value)
            except ValueError:
                pass
    except TypeError:
        pass
    if target.parent:
        value.parent_section = target.parent
        print(value.parent_section)
    else:
        value.parent_section = None
        value.parent_common_name = value.common_name


# Packet Event Listeners
@event.listens_for(Packet.amount, 'set', retval=True)
def htmlize_amount(target, value, oldvalue, initiatior):
    """Convert fractions in amount to HTML."""
    return html_fractions(value) if value else value


# Image Event Listeners
@event.listens_for(Image, 'before_delete')
def delete_image_file_before_delete(mapper, connection, target):
    """Delete image file of `Image` instance before the instance is deleted."""
    try:
        target.path.unlink()
        Image.delete_empty_folders(target.path)
    except FileNotFoundError:
        pass


if __name__ == '__main__':  # pragma: no cover
    import doctest
    doctest.testmod()
